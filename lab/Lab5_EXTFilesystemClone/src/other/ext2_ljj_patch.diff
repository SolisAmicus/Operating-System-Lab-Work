diff -urN fs/ext2/acl.c fs/ext2_ljj/acl.c
--- fs/ext2/acl.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/acl.c	2024-11-04 11:48:27.268696697 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/acl.c
+ * linux/fs/ext2_ljj/acl.c
  *
  * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>
  */
@@ -9,7 +9,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 #include "acl.h"
 
@@ -17,7 +17,7 @@
  * Convert from filesystem to in-memory representation.
  */
 static struct posix_acl *
-ext2_acl_from_disk(const void *value, size_t size)
+ext2_ljj_acl_from_disk(const void *value, size_t size)
 {
 	const char *end = (char *)value + size;
 	int n, count;
@@ -25,13 +25,13 @@
 
 	if (!value)
 		return NULL;
-	if (size < sizeof(ext2_acl_header))
+	if (size < sizeof(ext2_ljj_acl_header))
 		 return ERR_PTR(-EINVAL);
-	if (((ext2_acl_header *)value)->a_version !=
+	if (((ext2_ljj_acl_header *)value)->a_version !=
 	    cpu_to_le32(EXT2_ACL_VERSION))
 		return ERR_PTR(-EINVAL);
-	value = (char *)value + sizeof(ext2_acl_header);
-	count = ext2_acl_count(size);
+	value = (char *)value + sizeof(ext2_ljj_acl_header);
+	count = ext2_ljj_acl_count(size);
 	if (count < 0)
 		return ERR_PTR(-EINVAL);
 	if (count == 0)
@@ -40,9 +40,9 @@
 	if (!acl)
 		return ERR_PTR(-ENOMEM);
 	for (n=0; n < count; n++) {
-		ext2_acl_entry *entry =
-			(ext2_acl_entry *)value;
-		if ((char *)value + sizeof(ext2_acl_entry_short) > end)
+		ext2_ljj_acl_entry *entry =
+			(ext2_ljj_acl_entry *)value;
+		if ((char *)value + sizeof(ext2_ljj_acl_entry_short) > end)
 			goto fail;
 		acl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);
 		acl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);
@@ -52,11 +52,11 @@
 			case ACL_MASK:
 			case ACL_OTHER:
 				value = (char *)value +
-					sizeof(ext2_acl_entry_short);
+					sizeof(ext2_ljj_acl_entry_short);
 				break;
 
 			case ACL_USER:
-				value = (char *)value + sizeof(ext2_acl_entry);
+				value = (char *)value + sizeof(ext2_ljj_acl_entry);
 				if ((char *)value > end)
 					goto fail;
 				acl->a_entries[n].e_uid =
@@ -64,7 +64,7 @@
 						  le32_to_cpu(entry->e_id));
 				break;
 			case ACL_GROUP:
-				value = (char *)value + sizeof(ext2_acl_entry);
+				value = (char *)value + sizeof(ext2_ljj_acl_entry);
 				if ((char *)value > end)
 					goto fail;
 				acl->a_entries[n].e_gid =
@@ -89,41 +89,41 @@
  * Convert from in-memory to filesystem representation.
  */
 static void *
-ext2_acl_to_disk(const struct posix_acl *acl, size_t *size)
+ext2_ljj_acl_to_disk(const struct posix_acl *acl, size_t *size)
 {
-	ext2_acl_header *ext_acl;
+	ext2_ljj_acl_header *ext_acl;
 	char *e;
 	size_t n;
 
-	*size = ext2_acl_size(acl->a_count);
-	ext_acl = kmalloc(sizeof(ext2_acl_header) + acl->a_count *
-			sizeof(ext2_acl_entry), GFP_KERNEL);
+	*size = ext2_ljj_acl_size(acl->a_count);
+	ext_acl = kmalloc(sizeof(ext2_ljj_acl_header) + acl->a_count *
+			sizeof(ext2_ljj_acl_entry), GFP_KERNEL);
 	if (!ext_acl)
 		return ERR_PTR(-ENOMEM);
 	ext_acl->a_version = cpu_to_le32(EXT2_ACL_VERSION);
-	e = (char *)ext_acl + sizeof(ext2_acl_header);
+	e = (char *)ext_acl + sizeof(ext2_ljj_acl_header);
 	for (n=0; n < acl->a_count; n++) {
 		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
-		ext2_acl_entry *entry = (ext2_acl_entry *)e;
+		ext2_ljj_acl_entry *entry = (ext2_ljj_acl_entry *)e;
 		entry->e_tag  = cpu_to_le16(acl_e->e_tag);
 		entry->e_perm = cpu_to_le16(acl_e->e_perm);
 		switch(acl_e->e_tag) {
 			case ACL_USER:
 				entry->e_id = cpu_to_le32(
 					from_kuid(&init_user_ns, acl_e->e_uid));
-				e += sizeof(ext2_acl_entry);
+				e += sizeof(ext2_ljj_acl_entry);
 				break;
 			case ACL_GROUP:
 				entry->e_id = cpu_to_le32(
 					from_kgid(&init_user_ns, acl_e->e_gid));
-				e += sizeof(ext2_acl_entry);
+				e += sizeof(ext2_ljj_acl_entry);
 				break;
 
 			case ACL_USER_OBJ:
 			case ACL_GROUP_OBJ:
 			case ACL_MASK:
 			case ACL_OTHER:
-				e += sizeof(ext2_acl_entry_short);
+				e += sizeof(ext2_ljj_acl_entry_short);
 				break;
 
 			default:
@@ -141,7 +141,7 @@
  * inode->i_mutex: don't care
  */
 struct posix_acl *
-ext2_get_acl(struct inode *inode, int type, bool rcu)
+ext2_ljj_get_acl(struct inode *inode, int type, bool rcu)
 {
 	int name_index;
 	char *value = NULL;
@@ -161,15 +161,15 @@
 	default:
 		BUG();
 	}
-	retval = ext2_xattr_get(inode, name_index, "", NULL, 0);
+	retval = ext2_ljj_xattr_get(inode, name_index, "", NULL, 0);
 	if (retval > 0) {
 		value = kmalloc(retval, GFP_KERNEL);
 		if (!value)
 			return ERR_PTR(-ENOMEM);
-		retval = ext2_xattr_get(inode, name_index, "", value, retval);
+		retval = ext2_ljj_xattr_get(inode, name_index, "", value, retval);
 	}
 	if (retval > 0)
-		acl = ext2_acl_from_disk(value, retval);
+		acl = ext2_ljj_acl_from_disk(value, retval);
 	else if (retval == -ENODATA || retval == -ENOSYS)
 		acl = NULL;
 	else
@@ -180,7 +180,7 @@
 }
 
 static int
-__ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+__ext2_ljj_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
 	int name_index;
 	void *value = NULL;
@@ -202,12 +202,12 @@
 			return -EINVAL;
 	}
  	if (acl) {
-		value = ext2_acl_to_disk(acl, &size);
+		value = ext2_ljj_acl_to_disk(acl, &size);
 		if (IS_ERR(value))
 			return (int)PTR_ERR(value);
 	}
 
-	error = ext2_xattr_set(inode, name_index, "", value, size, 0);
+	error = ext2_ljj_xattr_set(inode, name_index, "", value, size, 0);
 
 	kfree(value);
 	if (!error)
@@ -219,7 +219,7 @@
  * inode->i_mutex: down
  */
 int
-ext2_set_acl(struct user_namespace *mnt_userns, struct inode *inode,
+ext2_ljj_set_acl(struct user_namespace *mnt_userns, struct inode *inode,
 	     struct posix_acl *acl, int type)
 {
 	int error;
@@ -233,7 +233,7 @@
 			return error;
 		update_mode = 1;
 	}
-	error = __ext2_set_acl(inode, acl, type);
+	error = __ext2_ljj_set_acl(inode, acl, type);
 	if (!error && update_mode) {
 		inode->i_mode = mode;
 		inode->i_ctime = current_time(inode);
@@ -243,13 +243,13 @@
 }
 
 /*
- * Initialize the ACLs of a new inode. Called from ext2_new_inode.
+ * Initialize the ACLs of a new inode. Called from ext2_ljj_new_inode.
  *
  * dir->i_mutex: down
  * inode->i_mutex: up (access to inode is still exclusive)
  */
 int
-ext2_init_acl(struct inode *inode, struct inode *dir)
+ext2_ljj_init_acl(struct inode *inode, struct inode *dir)
 {
 	struct posix_acl *default_acl, *acl;
 	int error;
@@ -259,14 +259,14 @@
 		return error;
 
 	if (default_acl) {
-		error = __ext2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
+		error = __ext2_ljj_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
 		posix_acl_release(default_acl);
 	} else {
 		inode->i_default_acl = NULL;
 	}
 	if (acl) {
 		if (!error)
-			error = __ext2_set_acl(inode, acl, ACL_TYPE_ACCESS);
+			error = __ext2_ljj_set_acl(inode, acl, ACL_TYPE_ACCESS);
 		posix_acl_release(acl);
 	} else {
 		inode->i_acl = NULL;
diff -urN fs/ext2/acl.h fs/ext2_ljj/acl.h
--- fs/ext2/acl.h	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/acl.h	2024-11-04 11:48:27.265696908 +0800
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
-  File: fs/ext2/acl.h
+  File: fs/ext2_ljj/acl.h
 
   (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
 */
@@ -13,59 +13,59 @@
 	__le16		e_tag;
 	__le16		e_perm;
 	__le32		e_id;
-} ext2_acl_entry;
+} ext2_ljj_acl_entry;
 
 typedef struct {
 	__le16		e_tag;
 	__le16		e_perm;
-} ext2_acl_entry_short;
+} ext2_ljj_acl_entry_short;
 
 typedef struct {
 	__le32		a_version;
-} ext2_acl_header;
+} ext2_ljj_acl_header;
 
-static inline size_t ext2_acl_size(int count)
+static inline size_t ext2_ljj_acl_size(int count)
 {
 	if (count <= 4) {
-		return sizeof(ext2_acl_header) +
-		       count * sizeof(ext2_acl_entry_short);
+		return sizeof(ext2_ljj_acl_header) +
+		       count * sizeof(ext2_ljj_acl_entry_short);
 	} else {
-		return sizeof(ext2_acl_header) +
-		       4 * sizeof(ext2_acl_entry_short) +
-		       (count - 4) * sizeof(ext2_acl_entry);
+		return sizeof(ext2_ljj_acl_header) +
+		       4 * sizeof(ext2_ljj_acl_entry_short) +
+		       (count - 4) * sizeof(ext2_ljj_acl_entry);
 	}
 }
 
-static inline int ext2_acl_count(size_t size)
+static inline int ext2_ljj_acl_count(size_t size)
 {
 	ssize_t s;
-	size -= sizeof(ext2_acl_header);
-	s = size - 4 * sizeof(ext2_acl_entry_short);
+	size -= sizeof(ext2_ljj_acl_header);
+	s = size - 4 * sizeof(ext2_ljj_acl_entry_short);
 	if (s < 0) {
-		if (size % sizeof(ext2_acl_entry_short))
+		if (size % sizeof(ext2_ljj_acl_entry_short))
 			return -1;
-		return size / sizeof(ext2_acl_entry_short);
+		return size / sizeof(ext2_ljj_acl_entry_short);
 	} else {
-		if (s % sizeof(ext2_acl_entry))
+		if (s % sizeof(ext2_ljj_acl_entry))
 			return -1;
-		return s / sizeof(ext2_acl_entry) + 4;
+		return s / sizeof(ext2_ljj_acl_entry) + 4;
 	}
 }
 
 #ifdef CONFIG_EXT2_FS_POSIX_ACL
 
 /* acl.c */
-extern struct posix_acl *ext2_get_acl(struct inode *inode, int type, bool rcu);
-extern int ext2_set_acl(struct user_namespace *mnt_userns, struct inode *inode,
+extern struct posix_acl *ext2_ljj_get_acl(struct inode *inode, int type, bool rcu);
+extern int ext2_ljj_set_acl(struct user_namespace *mnt_userns, struct inode *inode,
 			struct posix_acl *acl, int type);
-extern int ext2_init_acl (struct inode *, struct inode *);
+extern int ext2_ljj_init_acl (struct inode *, struct inode *);
 
 #else
 #include <linux/sched.h>
-#define ext2_get_acl	NULL
-#define ext2_set_acl	NULL
+#define ext2_ljj_get_acl	NULL
+#define ext2_ljj_set_acl	NULL
 
-static inline int ext2_init_acl (struct inode *inode, struct inode *dir)
+static inline int ext2_ljj_init_acl (struct inode *inode, struct inode *dir)
 {
 	return 0;
 }
diff -urN fs/ext2/balloc.c fs/ext2_ljj/balloc.c
--- fs/ext2/balloc.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/balloc.c	2024-11-04 11:48:27.264696979 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *  linux/fs/ext2/balloc.c
+ *  linux/fs/ext2_ljj/balloc.c
  *
  * Copyright (C) 1992, 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -12,7 +12,7 @@
  *        David S. Miller (davem@caip.rutgers.edu), 1995
  */
 
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include <linux/quotaops.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
@@ -32,20 +32,20 @@
  * The file system contains group descriptors which are located after the
  * super block.  Each descriptor contains the number of the bitmap block and
  * the free blocks count in the block.  The descriptors are loaded in memory
- * when a file system is mounted (see ext2_fill_super).
+ * when a file system is mounted (see ext2_ljj_fill_super).
  */
 
 
 #define in_range(b, first, len)	((b) >= (first) && (b) <= (first) + (len) - 1)
 
-struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,
+struct ext2_ljj_group_desc * ext2_ljj_get_group_desc(struct super_block * sb,
 					     unsigned int block_group,
 					     struct buffer_head ** bh)
 {
 	unsigned long group_desc;
 	unsigned long offset;
-	struct ext2_group_desc * desc;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_group_desc * desc;
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 
 	if (block_group >= sbi->s_groups_count) {
 		WARN(1, "block_group >= groups_count - "
@@ -64,31 +64,31 @@
 		return NULL;
 	}
 
-	desc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;
+	desc = (struct ext2_ljj_group_desc *) sbi->s_group_desc[group_desc]->b_data;
 	if (bh)
 		*bh = sbi->s_group_desc[group_desc];
 	return desc + offset;
 }
 
-static int ext2_valid_block_bitmap(struct super_block *sb,
-					struct ext2_group_desc *desc,
+static int ext2_ljj_valid_block_bitmap(struct super_block *sb,
+					struct ext2_ljj_group_desc *desc,
 					unsigned int block_group,
 					struct buffer_head *bh)
 {
-	ext2_grpblk_t offset;
-	ext2_grpblk_t next_zero_bit;
-	ext2_fsblk_t bitmap_blk;
-	ext2_fsblk_t group_first_block;
-	ext2_grpblk_t max_bit;
+	ext2_ljj_grpblk_t offset;
+	ext2_ljj_grpblk_t next_zero_bit;
+	ext2_ljj_fsblk_t bitmap_blk;
+	ext2_ljj_fsblk_t group_first_block;
+	ext2_ljj_grpblk_t max_bit;
 
-	group_first_block = ext2_group_first_block_no(sb, block_group);
-	max_bit = ext2_group_last_block_no(sb, block_group) - group_first_block;
+	group_first_block = ext2_ljj_group_first_block_no(sb, block_group);
+	max_bit = ext2_ljj_group_last_block_no(sb, block_group) - group_first_block;
 
 	/* check whether block bitmap block number is set */
 	bitmap_blk = le32_to_cpu(desc->bg_block_bitmap);
 	offset = bitmap_blk - group_first_block;
 	if (offset < 0 || offset > max_bit ||
-	    !ext2_test_bit(offset, bh->b_data))
+	    !ext2_ljj_test_bit(offset, bh->b_data))
 		/* bad block bitmap */
 		goto err_out;
 
@@ -96,7 +96,7 @@
 	bitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);
 	offset = bitmap_blk - group_first_block;
 	if (offset < 0 || offset > max_bit ||
-	    !ext2_test_bit(offset, bh->b_data))
+	    !ext2_ljj_test_bit(offset, bh->b_data))
 		/* bad block bitmap */
 		goto err_out;
 
@@ -106,7 +106,7 @@
 	if (offset < 0 || offset > max_bit ||
 	    offset + EXT2_SB(sb)->s_itb_per_group - 1 > max_bit)
 		goto err_out;
-	next_zero_bit = ext2_find_next_zero_bit(bh->b_data,
+	next_zero_bit = ext2_ljj_find_next_zero_bit(bh->b_data,
 				offset + EXT2_SB(sb)->s_itb_per_group,
 				offset);
 	if (next_zero_bit >= offset + EXT2_SB(sb)->s_itb_per_group)
@@ -114,7 +114,7 @@
 		return 1;
 
 err_out:
-	ext2_error(sb, __func__,
+	ext2_ljj_error(sb, __func__,
 			"Invalid block bitmap - "
 			"block_group = %d, block = %lu",
 			block_group, bitmap_blk);
@@ -130,18 +130,18 @@
 static struct buffer_head *
 read_block_bitmap(struct super_block *sb, unsigned int block_group)
 {
-	struct ext2_group_desc * desc;
+	struct ext2_ljj_group_desc * desc;
 	struct buffer_head * bh = NULL;
-	ext2_fsblk_t bitmap_blk;
+	ext2_ljj_fsblk_t bitmap_blk;
 	int ret;
 
-	desc = ext2_get_group_desc(sb, block_group, NULL);
+	desc = ext2_ljj_get_group_desc(sb, block_group, NULL);
 	if (!desc)
 		return NULL;
 	bitmap_blk = le32_to_cpu(desc->bg_block_bitmap);
 	bh = sb_getblk(sb, bitmap_blk);
 	if (unlikely(!bh)) {
-		ext2_error(sb, __func__,
+		ext2_ljj_error(sb, __func__,
 			    "Cannot read block bitmap - "
 			    "block_group = %d, block_bitmap = %u",
 			    block_group, le32_to_cpu(desc->bg_block_bitmap));
@@ -152,14 +152,14 @@
 		return bh;
 	if (ret < 0) {
 		brelse(bh);
-		ext2_error(sb, __func__,
+		ext2_ljj_error(sb, __func__,
 			    "Cannot read block bitmap - "
 			    "block_group = %d, block_bitmap = %u",
 			    block_group, le32_to_cpu(desc->bg_block_bitmap));
 		return NULL;
 	}
 
-	ext2_valid_block_bitmap(sb, desc, block_group, bh);
+	ext2_ljj_valid_block_bitmap(sb, desc, block_group, bh);
 	/*
 	 * file system mounted not to panic on error, continue with corrupt
 	 * bitmap
@@ -168,10 +168,10 @@
 }
 
 static void group_adjust_blocks(struct super_block *sb, int group_no,
-	struct ext2_group_desc *desc, struct buffer_head *bh, int count)
+	struct ext2_ljj_group_desc *desc, struct buffer_head *bh, int count)
 {
 	if (count) {
-		struct ext2_sb_info *sbi = EXT2_SB(sb);
+		struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 		unsigned free_blocks;
 
 		spin_lock(sb_bgl_lock(sbi, group_no));
@@ -208,7 +208,7 @@
 			      const char *fn)
 {
 	struct rb_node *n;
-	struct ext2_reserve_window_node *rsv, *prev;
+	struct ext2_ljj_reserve_window_node *rsv, *prev;
 	int bad;
 
 restart:
@@ -218,7 +218,7 @@
 
 	printk("Block Allocation Reservation Windows Map (%s):\n", fn);
 	while (n) {
-		rsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);
+		rsv = rb_entry(n, struct ext2_ljj_reserve_window_node, rsv_node);
 		if (verbose)
 			printk("reservation window 0x%p "
 				"start: %lu, end: %lu\n",
@@ -269,13 +269,13 @@
  * otherwise, return 0;
  */
 static int
-goal_in_my_reservation(struct ext2_reserve_window *rsv, ext2_grpblk_t grp_goal,
+goal_in_my_reservation(struct ext2_ljj_reserve_window *rsv, ext2_ljj_grpblk_t grp_goal,
 			unsigned int group, struct super_block * sb)
 {
-	ext2_fsblk_t group_first_block, group_last_block;
+	ext2_ljj_fsblk_t group_first_block, group_last_block;
 
-	group_first_block = ext2_group_first_block_no(sb, group);
-	group_last_block = ext2_group_last_block_no(sb, group);
+	group_first_block = ext2_ljj_group_first_block_no(sb, group);
+	group_last_block = ext2_ljj_group_last_block_no(sb, group);
 
 	if ((rsv->_rsv_start > group_last_block) ||
 	    (rsv->_rsv_end < group_first_block))
@@ -295,17 +295,17 @@
  * if the goal is not in any window.
  * Returns NULL if there are no windows or if all windows start after the goal.
  */
-static struct ext2_reserve_window_node *
-search_reserve_window(struct rb_root *root, ext2_fsblk_t goal)
+static struct ext2_ljj_reserve_window_node *
+search_reserve_window(struct rb_root *root, ext2_ljj_fsblk_t goal)
 {
 	struct rb_node *n = root->rb_node;
-	struct ext2_reserve_window_node *rsv;
+	struct ext2_ljj_reserve_window_node *rsv;
 
 	if (!n)
 		return NULL;
 
 	do {
-		rsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);
+		rsv = rb_entry(n, struct ext2_ljj_reserve_window_node, rsv_node);
 
 		if (goal < rsv->rsv_start)
 			n = n->rb_left;
@@ -322,33 +322,33 @@
 	 */
 	if (rsv->rsv_start > goal) {
 		n = rb_prev(&rsv->rsv_node);
-		rsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);
+		rsv = rb_entry(n, struct ext2_ljj_reserve_window_node, rsv_node);
 	}
 	return rsv;
 }
 
 /*
- * ext2_rsv_window_add() -- Insert a window to the block reservation rb tree.
+ * ext2_ljj_rsv_window_add() -- Insert a window to the block reservation rb tree.
  * @sb:			super block
  * @rsv:		reservation window to add
  *
  * Must be called with rsv_lock held.
  */
-void ext2_rsv_window_add(struct super_block *sb,
-		    struct ext2_reserve_window_node *rsv)
+void ext2_ljj_rsv_window_add(struct super_block *sb,
+		    struct ext2_ljj_reserve_window_node *rsv)
 {
 	struct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;
 	struct rb_node *node = &rsv->rsv_node;
-	ext2_fsblk_t start = rsv->rsv_start;
+	ext2_ljj_fsblk_t start = rsv->rsv_start;
 
 	struct rb_node ** p = &root->rb_node;
 	struct rb_node * parent = NULL;
-	struct ext2_reserve_window_node *this;
+	struct ext2_ljj_reserve_window_node *this;
 
 	while (*p)
 	{
 		parent = *p;
-		this = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);
+		this = rb_entry(parent, struct ext2_ljj_reserve_window_node, rsv_node);
 
 		if (start < this->rsv_start)
 			p = &(*p)->rb_left;
@@ -374,7 +374,7 @@
  * rsv_lock held.
  */
 static void rsv_window_remove(struct super_block *sb,
-			      struct ext2_reserve_window_node *rsv)
+			      struct ext2_ljj_reserve_window_node *rsv)
 {
 	rsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;
 	rsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;
@@ -388,42 +388,42 @@
  *
  * returns 1 if the end block is EXT2_RESERVE_WINDOW_NOT_ALLOCATED.
  */
-static inline int rsv_is_empty(struct ext2_reserve_window *rsv)
+static inline int rsv_is_empty(struct ext2_ljj_reserve_window *rsv)
 {
 	/* a valid reservation end block could not be 0 */
 	return (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);
 }
 
 /**
- * ext2_init_block_alloc_info()
+ * ext2_ljj_init_block_alloc_info()
  * @inode:		file inode structure
  *
  * Allocate and initialize the  reservation window structure, and
- * link the window to the ext2 inode structure at last
+ * link the window to the ext2_ljj inode structure at last
  *
  * The reservation window structure is only dynamically allocated
- * and linked to ext2 inode the first time the open file
- * needs a new block. So, before every ext2_new_block(s) call, for
+ * and linked to ext2_ljj inode the first time the open file
+ * needs a new block. So, before every ext2_ljj_new_block(s) call, for
  * regular files, we should check whether the reservation window
  * structure exists or not. In the latter case, this function is called.
  * Fail to do so will result in block reservation being turned off for that
  * open file.
  *
- * This function is called from ext2_get_blocks_handle(), also called
+ * This function is called from ext2_ljj_get_blocks_handle(), also called
  * when setting the reservation window size through ioctl before the file
  * is open for write (needs block allocation).
  *
  * Needs truncate_mutex protection prior to calling this function.
  */
-void ext2_init_block_alloc_info(struct inode *inode)
+void ext2_ljj_init_block_alloc_info(struct inode *inode)
 {
-	struct ext2_inode_info *ei = EXT2_I(inode);
-	struct ext2_block_alloc_info *block_i;
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_block_alloc_info *block_i;
 	struct super_block *sb = inode->i_sb;
 
 	block_i = kmalloc(sizeof(*block_i), GFP_NOFS);
 	if (block_i) {
-		struct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;
+		struct ext2_ljj_reserve_window_node *rsv = &block_i->rsv_window_node;
 
 		rsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;
 		rsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;
@@ -445,22 +445,22 @@
 }
 
 /**
- * ext2_discard_reservation()
+ * ext2_ljj_discard_reservation()
  * @inode:		inode
  *
  * Discard(free) block reservation window on last file close, or truncate
  * or at last iput().
  *
  * It is being called in three cases:
- * 	ext2_release_file(): last writer closes the file
- * 	ext2_clear_inode(): last iput(), when nobody links to this file.
- * 	ext2_truncate(): when the block indirect map is about to change.
- */
-void ext2_discard_reservation(struct inode *inode)
-{
-	struct ext2_inode_info *ei = EXT2_I(inode);
-	struct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;
-	struct ext2_reserve_window_node *rsv;
+ * 	ext2_ljj_release_file(): last writer closes the file
+ * 	ext2_ljj_clear_inode(): last iput(), when nobody links to this file.
+ * 	ext2_ljj_truncate(): when the block indirect map is about to change.
+ */
+void ext2_ljj_discard_reservation(struct inode *inode)
+{
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_block_alloc_info *block_i = ei->i_block_alloc_info;
+	struct ext2_ljj_reserve_window_node *rsv;
 	spinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;
 
 	if (!block_i)
@@ -476,12 +476,12 @@
 }
 
 /**
- * ext2_free_blocks() -- Free given blocks and update quota and i_blocks
+ * ext2_ljj_free_blocks() -- Free given blocks and update quota and i_blocks
  * @inode:		inode
  * @block:		start physical block to free
  * @count:		number of blocks to free
  */
-void ext2_free_blocks (struct inode * inode, unsigned long block,
+void ext2_ljj_free_blocks (struct inode * inode, unsigned long block,
 		       unsigned long count)
 {
 	struct buffer_head *bitmap_bh = NULL;
@@ -491,19 +491,19 @@
 	unsigned long i;
 	unsigned long overflow;
 	struct super_block * sb = inode->i_sb;
-	struct ext2_sb_info * sbi = EXT2_SB(sb);
-	struct ext2_group_desc * desc;
-	struct ext2_super_block * es = sbi->s_es;
+	struct ext2_ljj_sb_info * sbi = EXT2_SB(sb);
+	struct ext2_ljj_group_desc * desc;
+	struct ext2_ljj_super_block * es = sbi->s_es;
 	unsigned freed = 0, group_freed;
 
-	if (!ext2_data_block_valid(sbi, block, count)) {
-		ext2_error (sb, "ext2_free_blocks",
+	if (!ext2_ljj_data_block_valid(sbi, block, count)) {
+		ext2_ljj_error (sb, "ext2_ljj_free_blocks",
 			    "Freeing blocks not in datazone - "
 			    "block = %lu, count = %lu", block, count);
 		goto error_return;
 	}
 
-	ext2_debug ("freeing block(s) %lu-%lu\n", block, block + count - 1);
+	ext2_ljj_debug ("freeing block(s) %lu-%lu\n", block, block + count - 1);
 
 do_more:
 	overflow = 0;
@@ -524,7 +524,7 @@
 	if (!bitmap_bh)
 		goto error_return;
 
-	desc = ext2_get_group_desc (sb, block_group, &bh2);
+	desc = ext2_ljj_get_group_desc (sb, block_group, &bh2);
 	if (!desc)
 		goto error_return;
 
@@ -534,7 +534,7 @@
 		      sbi->s_itb_per_group) ||
 	    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),
 		      sbi->s_itb_per_group)) {
-		ext2_error (sb, "ext2_free_blocks",
+		ext2_ljj_error (sb, "ext2_ljj_free_blocks",
 			    "Freeing blocks in system zones - "
 			    "Block = %lu, count = %lu",
 			    block, count);
@@ -542,9 +542,9 @@
 	}
 
 	for (i = 0, group_freed = 0; i < count; i++) {
-		if (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),
+		if (!ext2_ljj_clear_bit_atomic(sb_bgl_lock(sbi, block_group),
 						bit + i, bitmap_bh->b_data)) {
-			ext2_error(sb, __func__,
+			ext2_ljj_error(sb, __func__,
 				"bit already cleared for block %lu", block + i);
 		} else {
 			group_freed++;
@@ -581,13 +581,13 @@
  * The bitmap search --- search forward through the actual bitmap on disk until
  * we find a bit free.
  */
-static ext2_grpblk_t
-bitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,
-					ext2_grpblk_t maxblocks)
+static ext2_ljj_grpblk_t
+bitmap_search_next_usable_block(ext2_ljj_grpblk_t start, struct buffer_head *bh,
+					ext2_ljj_grpblk_t maxblocks)
 {
-	ext2_grpblk_t next;
+	ext2_ljj_grpblk_t next;
 
-	next = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);
+	next = ext2_ljj_find_next_zero_bit(bh->b_data, maxblocks, start);
 	if (next >= maxblocks)
 		return -1;
 	return next;
@@ -605,10 +605,10 @@
  * the initial goal; then for a free byte somewhere in the bitmap;
  * then for any free bit in the bitmap.
  */
-static ext2_grpblk_t
+static ext2_ljj_grpblk_t
 find_next_usable_block(int start, struct buffer_head *bh, int maxblocks)
 {
-	ext2_grpblk_t here, next;
+	ext2_ljj_grpblk_t here, next;
 	char *p, *r;
 
 	if (start > 0) {
@@ -620,13 +620,13 @@
 		 * less than EXT2_BLOCKS_PER_GROUP. Aligning up to the
 		 * next 64-bit boundary is simple..
 		 */
-		ext2_grpblk_t end_goal = (start + 63) & ~63;
+		ext2_ljj_grpblk_t end_goal = (start + 63) & ~63;
 		if (end_goal > maxblocks)
 			end_goal = maxblocks;
-		here = ext2_find_next_zero_bit(bh->b_data, end_goal, start);
+		here = ext2_ljj_find_next_zero_bit(bh->b_data, end_goal, start);
 		if (here < end_goal)
 			return here;
-		ext2_debug("Bit not found near goal\n");
+		ext2_ljj_debug("Bit not found near goal\n");
 	}
 
 	here = start;
@@ -645,7 +645,7 @@
 }
 
 /**
- * ext2_try_to_allocate()
+ * ext2_ljj_try_to_allocate()
  * @sb:			superblock
  * @group:		given allocation block group
  * @bitmap_bh:		bufferhead holds the block bitmap
@@ -667,14 +667,14 @@
  * new bitmap.
  */
 static int
-ext2_try_to_allocate(struct super_block *sb, int group,
-			struct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,
+ext2_ljj_try_to_allocate(struct super_block *sb, int group,
+			struct buffer_head *bitmap_bh, ext2_ljj_grpblk_t grp_goal,
 			unsigned long *count,
-			struct ext2_reserve_window *my_rsv)
+			struct ext2_ljj_reserve_window *my_rsv)
 {
-	ext2_fsblk_t group_first_block = ext2_group_first_block_no(sb, group);
-	ext2_fsblk_t group_last_block = ext2_group_last_block_no(sb, group);
-       	ext2_grpblk_t start, end;
+	ext2_ljj_fsblk_t group_first_block = ext2_ljj_group_first_block_no(sb, group);
+	ext2_ljj_fsblk_t group_last_block = ext2_ljj_group_last_block_no(sb, group);
+       	ext2_ljj_grpblk_t start, end;
 	unsigned long num = 0;
 
 	start = 0;
@@ -698,7 +698,7 @@
 			int i;
 
 			for (i = 0; i < 7 && grp_goal > start &&
-					!ext2_test_bit(grp_goal - 1,
+					!ext2_ljj_test_bit(grp_goal - 1,
 					     		bitmap_bh->b_data);
 			     		i++, grp_goal--)
 				;
@@ -706,7 +706,7 @@
 	}
 
 	for (; num < *count && grp_goal < end; grp_goal++) {
-		if (ext2_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group),
+		if (ext2_ljj_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group),
 					grp_goal, bitmap_bh->b_data)) {
 			if (num == 0)
 				continue;
@@ -757,15 +757,15 @@
  *
  */
 static int find_next_reservable_window(
-				struct ext2_reserve_window_node *search_head,
-				struct ext2_reserve_window_node *my_rsv,
+				struct ext2_ljj_reserve_window_node *search_head,
+				struct ext2_ljj_reserve_window_node *my_rsv,
 				struct super_block * sb,
-				ext2_fsblk_t start_block,
-				ext2_fsblk_t last_block)
+				ext2_ljj_fsblk_t start_block,
+				ext2_ljj_fsblk_t last_block)
 {
 	struct rb_node *next;
-	struct ext2_reserve_window_node *rsv, *prev;
-	ext2_fsblk_t cur;
+	struct ext2_ljj_reserve_window_node *rsv, *prev;
+	ext2_ljj_fsblk_t cur;
 	int size = my_rsv->rsv_goal_size;
 
 	/* TODO: make the start of the reservation window byte-aligned */
@@ -793,7 +793,7 @@
 
 		prev = rsv;
 		next = rb_next(&rsv->rsv_node);
-		rsv = rb_entry(next,struct ext2_reserve_window_node,rsv_node);
+		rsv = rb_entry(next,struct ext2_ljj_reserve_window_node,rsv_node);
 
 		/*
 		 * Reached the last reservation, we can just append to the
@@ -836,7 +836,7 @@
 	my_rsv->rsv_alloc_hit = 0;
 
 	if (prev != my_rsv)
-		ext2_rsv_window_add(sb, my_rsv);
+		ext2_ljj_rsv_window_add(sb, my_rsv);
 
 	return 0;
 }
@@ -878,20 +878,20 @@
  *	@bitmap_bh: the block group block bitmap
  *
  */
-static int alloc_new_reservation(struct ext2_reserve_window_node *my_rsv,
-		ext2_grpblk_t grp_goal, struct super_block *sb,
+static int alloc_new_reservation(struct ext2_ljj_reserve_window_node *my_rsv,
+		ext2_ljj_grpblk_t grp_goal, struct super_block *sb,
 		unsigned int group, struct buffer_head *bitmap_bh)
 {
-	struct ext2_reserve_window_node *search_head;
-	ext2_fsblk_t group_first_block, group_end_block, start_block;
-	ext2_grpblk_t first_free_block;
+	struct ext2_ljj_reserve_window_node *search_head;
+	ext2_ljj_fsblk_t group_first_block, group_end_block, start_block;
+	ext2_ljj_grpblk_t first_free_block;
 	struct rb_root *fs_rsv_root = &EXT2_SB(sb)->s_rsv_window_root;
 	unsigned long size;
 	int ret;
 	spinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;
 
-	group_first_block = ext2_group_first_block_no(sb, group);
-	group_end_block = ext2_group_last_block_no(sb, group);
+	group_first_block = ext2_ljj_group_first_block_no(sb, group);
+	group_end_block = ext2_ljj_group_last_block_no(sb, group);
 
 	if (grp_goal < 0)
 		start_block = group_first_block;
@@ -1012,18 +1012,18 @@
  * Attempt to expand the reservation window large enough to have
  * required number of free blocks
  *
- * Since ext2_try_to_allocate() will always allocate blocks within
+ * Since ext2_ljj_try_to_allocate() will always allocate blocks within
  * the reservation window range, if the window size is too small,
  * multiple blocks allocation has to stop at the end of the reservation
  * window. To make this more efficient, given the total number of
  * blocks needed and the current size of the window, we try to
  * expand the reservation window size if necessary on a best-effort
- * basis before ext2_new_blocks() tries to allocate blocks.
+ * basis before ext2_ljj_new_blocks() tries to allocate blocks.
  */
-static void try_to_extend_reservation(struct ext2_reserve_window_node *my_rsv,
+static void try_to_extend_reservation(struct ext2_ljj_reserve_window_node *my_rsv,
 			struct super_block *sb, int size)
 {
-	struct ext2_reserve_window_node *next_rsv;
+	struct ext2_ljj_reserve_window_node *next_rsv;
 	struct rb_node *next;
 	spinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;
 
@@ -1035,7 +1035,7 @@
 	if (!next)
 		my_rsv->rsv_end += size;
 	else {
-		next_rsv = rb_entry(next, struct ext2_reserve_window_node, rsv_node);
+		next_rsv = rb_entry(next, struct ext2_ljj_reserve_window_node, rsv_node);
 
 		if ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)
 			my_rsv->rsv_end += size;
@@ -1046,7 +1046,7 @@
 }
 
 /**
- * ext2_try_to_allocate_with_rsv()
+ * ext2_ljj_try_to_allocate_with_rsv()
  * @sb:			superblock
  * @group:		given allocation block group
  * @bitmap_bh:		bufferhead holds the block bitmap
@@ -1071,14 +1071,14 @@
  *
  * We use a red-black tree for the per-filesystem reservation list.
  */
-static ext2_grpblk_t
-ext2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,
-			struct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,
-			struct ext2_reserve_window_node * my_rsv,
+static ext2_ljj_grpblk_t
+ext2_ljj_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,
+			struct buffer_head *bitmap_bh, ext2_ljj_grpblk_t grp_goal,
+			struct ext2_ljj_reserve_window_node * my_rsv,
 			unsigned long *count)
 {
-	ext2_fsblk_t group_first_block, group_last_block;
-	ext2_grpblk_t ret = 0;
+	ext2_ljj_fsblk_t group_first_block, group_last_block;
+	ext2_ljj_grpblk_t ret = 0;
 	unsigned long num = *count;
 
 	/*
@@ -1088,7 +1088,7 @@
 	 * or last attempt to allocate a block with reservation turned on failed
 	 */
 	if (my_rsv == NULL) {
-		return ext2_try_to_allocate(sb, group, bitmap_bh,
+		return ext2_ljj_try_to_allocate(sb, group, bitmap_bh,
 						grp_goal, count, NULL);
 	}
 	/*
@@ -1097,8 +1097,8 @@
 	 * first block is a filesystem wide block number
 	 * first block is the block number of the first block in this group
 	 */
-	group_first_block = ext2_group_first_block_no(sb, group);
-	group_last_block = ext2_group_last_block_no(sb, group);
+	group_first_block = ext2_ljj_group_first_block_no(sb, group);
+	group_last_block = ext2_ljj_group_last_block_no(sb, group);
 
 	/*
 	 * Basically we will allocate a new block from inode's reservation
@@ -1143,7 +1143,7 @@
 			rsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);
 			BUG();
 		}
-		ret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,
+		ret = ext2_ljj_try_to_allocate(sb, group, bitmap_bh, grp_goal,
 					   &num, &my_rsv->rsv_window);
 		if (ret >= 0) {
 			my_rsv->rsv_alloc_hit += num;
@@ -1156,14 +1156,14 @@
 }
 
 /**
- * ext2_has_free_blocks()
+ * ext2_ljj_has_free_blocks()
  * @sbi:		in-core super block structure.
  *
  * Check if filesystem has at least 1 free block available for allocation.
  */
-static int ext2_has_free_blocks(struct ext2_sb_info *sbi)
+static int ext2_ljj_has_free_blocks(struct ext2_ljj_sb_info *sbi)
 {
-	ext2_fsblk_t free_blocks, root_blocks;
+	ext2_ljj_fsblk_t free_blocks, root_blocks;
 
 	free_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);
 	root_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);
@@ -1180,7 +1180,7 @@
  * Returns 1 if the passed-in block region is valid; 0 if some part overlaps
  * with filesystem metadata blocks.
  */
-int ext2_data_block_valid(struct ext2_sb_info *sbi, ext2_fsblk_t start_blk,
+int ext2_ljj_data_block_valid(struct ext2_ljj_sb_info *sbi, ext2_ljj_fsblk_t start_blk,
 			  unsigned int count)
 {
 	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
@@ -1197,38 +1197,38 @@
 }
 
 /*
- * ext2_new_blocks() -- core block(s) allocation function
+ * ext2_ljj_new_blocks() -- core block(s) allocation function
  * @inode:		file inode
  * @goal:		given target block(filesystem wide)
  * @count:		target number of blocks to allocate
  * @errp:		error code
  *
- * ext2_new_blocks uses a goal block to assist allocation.  If the goal is
+ * ext2_ljj_new_blocks uses a goal block to assist allocation.  If the goal is
  * free, or there is a free block within 32 blocks of the goal, that block
  * is allocated.  Otherwise a forward search is made for a free block; within 
  * each block group the search first looks for an entire free byte in the block
  * bitmap, and then for any free bit if that fails.
  * This function also updates quota and i_blocks field.
  */
-ext2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,
+ext2_ljj_fsblk_t ext2_ljj_new_blocks(struct inode *inode, ext2_ljj_fsblk_t goal,
 		    unsigned long *count, int *errp)
 {
 	struct buffer_head *bitmap_bh = NULL;
 	struct buffer_head *gdp_bh;
 	int group_no;
 	int goal_group;
-	ext2_grpblk_t grp_target_blk;	/* blockgroup relative goal block */
-	ext2_grpblk_t grp_alloc_blk;	/* blockgroup-relative allocated block*/
-	ext2_fsblk_t ret_block;		/* filesyetem-wide allocated block */
+	ext2_ljj_grpblk_t grp_target_blk;	/* blockgroup relative goal block */
+	ext2_ljj_grpblk_t grp_alloc_blk;	/* blockgroup-relative allocated block*/
+	ext2_ljj_fsblk_t ret_block;		/* filesyetem-wide allocated block */
 	int bgi;			/* blockgroup iteration index */
 	int performed_allocation = 0;
-	ext2_grpblk_t free_blocks;	/* number of free blocks in a group */
+	ext2_ljj_grpblk_t free_blocks;	/* number of free blocks in a group */
 	struct super_block *sb;
-	struct ext2_group_desc *gdp;
-	struct ext2_super_block *es;
-	struct ext2_sb_info *sbi;
-	struct ext2_reserve_window_node *my_rsv = NULL;
-	struct ext2_block_alloc_info *block_i;
+	struct ext2_ljj_group_desc *gdp;
+	struct ext2_ljj_super_block *es;
+	struct ext2_ljj_sb_info *sbi;
+	struct ext2_ljj_reserve_window_node *my_rsv = NULL;
+	struct ext2_ljj_block_alloc_info *block_i;
 	unsigned short windowsz = 0;
 	unsigned long ngroups;
 	unsigned long num = *count;
@@ -1248,7 +1248,7 @@
 
 	sbi = EXT2_SB(sb);
 	es = EXT2_SB(sb)->s_es;
-	ext2_debug("goal=%lu.\n", goal);
+	ext2_ljj_debug("goal=%lu.\n", goal);
 	/*
 	 * Allocate a block from reservation only when
 	 * filesystem is mounted with reservation(default,-o reservation), and
@@ -1264,7 +1264,7 @@
 			my_rsv = &block_i->rsv_window_node;
 	}
 
-	if (!ext2_has_free_blocks(sbi)) {
+	if (!ext2_ljj_has_free_blocks(sbi)) {
 		*errp = -ENOSPC;
 		goto out;
 	}
@@ -1279,7 +1279,7 @@
 			EXT2_BLOCKS_PER_GROUP(sb);
 	goal_group = group_no;
 retry_alloc:
-	gdp = ext2_get_group_desc(sb, group_no, &gdp_bh);
+	gdp = ext2_ljj_get_group_desc(sb, group_no, &gdp_bh);
 	if (!gdp)
 		goto io_error;
 
@@ -1306,7 +1306,7 @@
 		bitmap_bh = read_block_bitmap(sb, group_no);
 		if (!bitmap_bh)
 			goto io_error;
-		grp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,
+		grp_alloc_blk = ext2_ljj_try_to_allocate_with_rsv(sb, group_no,
 					bitmap_bh, grp_target_blk,
 					my_rsv, &num);
 		if (grp_alloc_blk >= 0)
@@ -1324,7 +1324,7 @@
 		group_no++;
 		if (group_no >= ngroups)
 			group_no = 0;
-		gdp = ext2_get_group_desc(sb, group_no, &gdp_bh);
+		gdp = ext2_ljj_get_group_desc(sb, group_no, &gdp_bh);
 		if (!gdp)
 			goto io_error;
 
@@ -1350,7 +1350,7 @@
 		/*
 		 * try to allocate block(s) from this group, without a goal(-1).
 		 */
-		grp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,
+		grp_alloc_blk = ext2_ljj_try_to_allocate_with_rsv(sb, group_no,
 					bitmap_bh, -1, my_rsv, &num);
 		if (grp_alloc_blk >= 0)
 			goto allocated;
@@ -1374,10 +1374,10 @@
 
 allocated:
 
-	ext2_debug("using block group %d(%d)\n",
+	ext2_ljj_debug("using block group %d(%d)\n",
 			group_no, gdp->bg_free_blocks_count);
 
-	ret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);
+	ret_block = grp_alloc_blk + ext2_ljj_group_first_block_no(sb, group_no);
 
 	if (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||
 	    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||
@@ -1385,12 +1385,12 @@
 		      EXT2_SB(sb)->s_itb_per_group) ||
 	    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),
 		      EXT2_SB(sb)->s_itb_per_group)) {
-		ext2_error(sb, "ext2_new_blocks",
+		ext2_ljj_error(sb, "ext2_ljj_new_blocks",
 			    "Allocating block in system zone - "
 			    "blocks from "E2FSBLK", length %lu",
 			    ret_block, num);
 		/*
-		 * ext2_try_to_allocate marked the blocks we allocated as in
+		 * ext2_ljj_try_to_allocate marked the blocks we allocated as in
 		 * use.  So we may want to selectively mark some of the blocks
 		 * as free
 		 */
@@ -1401,7 +1401,7 @@
 	performed_allocation = 1;
 
 	if (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {
-		ext2_error(sb, "ext2_new_blocks",
+		ext2_ljj_error(sb, "ext2_ljj_new_blocks",
 			    "block("E2FSBLK") >= blocks count(%d) - "
 			    "block_group = %d, es == %p ", ret_block,
 			le32_to_cpu(es->s_blocks_count), group_no, es);
@@ -1438,30 +1438,30 @@
 	return 0;
 }
 
-ext2_fsblk_t ext2_new_block(struct inode *inode, unsigned long goal, int *errp)
+ext2_ljj_fsblk_t ext2_ljj_new_block(struct inode *inode, unsigned long goal, int *errp)
 {
 	unsigned long count = 1;
 
-	return ext2_new_blocks(inode, goal, &count, errp);
+	return ext2_ljj_new_blocks(inode, goal, &count, errp);
 }
 
 #ifdef EXT2FS_DEBUG
 
-unsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)
+unsigned long ext2_ljj_count_free(struct buffer_head *map, unsigned int numchars)
 {
 	return numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);
 }
 
 #endif  /*  EXT2FS_DEBUG  */
 
-unsigned long ext2_count_free_blocks (struct super_block * sb)
+unsigned long ext2_ljj_count_free_blocks (struct super_block * sb)
 {
-	struct ext2_group_desc * desc;
+	struct ext2_ljj_group_desc * desc;
 	unsigned long desc_count = 0;
 	int i;
 #ifdef EXT2FS_DEBUG
 	unsigned long bitmap_count, x;
-	struct ext2_super_block *es;
+	struct ext2_ljj_super_block *es;
 
 	es = EXT2_SB(sb)->s_es;
 	desc_count = 0;
@@ -1469,7 +1469,7 @@
 	desc = NULL;
 	for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {
 		struct buffer_head *bitmap_bh;
-		desc = ext2_get_group_desc (sb, i, NULL);
+		desc = ext2_ljj_get_group_desc (sb, i, NULL);
 		if (!desc)
 			continue;
 		desc_count += le16_to_cpu(desc->bg_free_blocks_count);
@@ -1477,19 +1477,19 @@
 		if (!bitmap_bh)
 			continue;
 		
-		x = ext2_count_free(bitmap_bh, sb->s_blocksize);
+		x = ext2_ljj_count_free(bitmap_bh, sb->s_blocksize);
 		printk ("group %d: stored = %d, counted = %lu\n",
 			i, le16_to_cpu(desc->bg_free_blocks_count), x);
 		bitmap_count += x;
 		brelse(bitmap_bh);
 	}
-	printk("ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\n",
+	printk("ext2_ljj_count_free_blocks: stored = %lu, computed = %lu, %lu\n",
 		(long)le32_to_cpu(es->s_free_blocks_count),
 		desc_count, bitmap_count);
 	return bitmap_count;
 #else
         for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {
-                desc = ext2_get_group_desc (sb, i, NULL);
+                desc = ext2_ljj_get_group_desc (sb, i, NULL);
                 if (!desc)
                         continue;
                 desc_count += le16_to_cpu(desc->bg_free_blocks_count);
@@ -1507,7 +1507,7 @@
 	return num == a;
 }
 
-static int ext2_group_sparse(int group)
+static int ext2_ljj_group_sparse(int group)
 {
 	if (group <= 1)
 		return 1;
@@ -1516,23 +1516,23 @@
 }
 
 /**
- *	ext2_bg_has_super - number of blocks used by the superblock in group
+ *	ext2_ljj_bg_has_super - number of blocks used by the superblock in group
  *	@sb: superblock for filesystem
  *	@group: group number to check
  *
  *	Return the number of blocks used by the superblock (primary or backup)
  *	in this group.  Currently this will be only 0 or 1.
  */
-int ext2_bg_has_super(struct super_block *sb, int group)
+int ext2_ljj_bg_has_super(struct super_block *sb, int group)
 {
 	if (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&
-	    !ext2_group_sparse(group))
+	    !ext2_ljj_group_sparse(group))
 		return 0;
 	return 1;
 }
 
 /**
- *	ext2_bg_num_gdb - number of blocks used by the group table in group
+ *	ext2_ljj_bg_num_gdb - number of blocks used by the group table in group
  *	@sb: superblock for filesystem
  *	@group: group number to check
  *
@@ -1540,8 +1540,8 @@
  *	(primary or backup) in this group.  In the future there may be a
  *	different number of descriptor blocks in each group.
  */
-unsigned long ext2_bg_num_gdb(struct super_block *sb, int group)
+unsigned long ext2_ljj_bg_num_gdb(struct super_block *sb, int group)
 {
-	return ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;
+	return ext2_ljj_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;
 }
 
diff -urN fs/ext2/built-in.a fs/ext2_ljj/built-in.a
--- fs/ext2/built-in.a	1970-01-01 08:00:00.000000000 +0800
+++ fs/ext2_ljj/built-in.a	2024-11-04 11:57:04.750910767 +0800
@@ -0,0 +1 @@
+!<arch>
diff -urN fs/ext2/.built-in.a.cmd fs/ext2_ljj/.built-in.a.cmd
--- fs/ext2/.built-in.a.cmd	1970-01-01 08:00:00.000000000 +0800
+++ fs/ext2_ljj/.built-in.a.cmd	2024-11-04 11:57:04.750910767 +0800
@@ -0,0 +1 @@
+cmd_fs/ext2_ljj/built-in.a := rm -f fs/ext2_ljj/built-in.a;  ar cDPrST fs/ext2_ljj/built-in.a
diff -urN fs/ext2/dir.c fs/ext2_ljj/dir.c
--- fs/ext2/dir.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/dir.c	2024-11-04 11:48:27.268696697 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *  linux/fs/ext2/dir.c
+ *  linux/fs/ext2_ljj/dir.c
  *
  * Copyright (C) 1992, 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -13,7 +13,7 @@
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
  *
- *  ext2 directory handling functions
+ *  ext2_ljj directory handling functions
  *
  *  Big-endian to little-endian byte-swapping/bitmaps by
  *        David S. Miller (davem@caip.rutgers.edu), 1995
@@ -22,20 +22,20 @@
  * and moved here. AV
  */
 
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include <linux/buffer_head.h>
 #include <linux/pagemap.h>
 #include <linux/swap.h>
 #include <linux/iversion.h>
 
-typedef struct ext2_dir_entry_2 ext2_dirent;
+typedef struct ext2_ljj_dir_entry_2 ext2_ljj_dirent;
 
 /*
  * Tests against MAX_REC_LEN etc were put in place for 64k block
  * sizes; if that is not possible on this arch, we can skip
  * those tests and speed things up.
  */
-static inline unsigned ext2_rec_len_from_disk(__le16 dlen)
+static inline unsigned ext2_ljj_rec_len_from_disk(__le16 dlen)
 {
 	unsigned len = le16_to_cpu(dlen);
 
@@ -46,7 +46,7 @@
 	return len;
 }
 
-static inline __le16 ext2_rec_len_to_disk(unsigned len)
+static inline __le16 ext2_ljj_rec_len_to_disk(unsigned len)
 {
 #if (PAGE_SIZE >= 65536)
 	if (len == (1 << 16))
@@ -58,10 +58,10 @@
 }
 
 /*
- * ext2 uses block-sized chunks. Arguably, sector-sized ones would be
+ * ext2_ljj uses block-sized chunks. Arguably, sector-sized ones would be
  * more robust, but we have what we have
  */
-static inline unsigned ext2_chunk_size(struct inode *inode)
+static inline unsigned ext2_ljj_chunk_size(struct inode *inode)
 {
 	return inode->i_sb->s_blocksize;
 }
@@ -71,7 +71,7 @@
  * byte in that page, plus one.
  */
 static unsigned
-ext2_last_byte(struct inode *inode, unsigned long page_nr)
+ext2_ljj_last_byte(struct inode *inode, unsigned long page_nr)
 {
 	unsigned last_byte = inode->i_size;
 
@@ -81,7 +81,7 @@
 	return last_byte;
 }
 
-static int ext2_commit_chunk(struct page *page, loff_t pos, unsigned len)
+static int ext2_ljj_commit_chunk(struct page *page, loff_t pos, unsigned len)
 {
 	struct address_space *mapping = page->mapping;
 	struct inode *dir = mapping->host;
@@ -106,15 +106,15 @@
 	return err;
 }
 
-static bool ext2_check_page(struct page *page, int quiet, char *kaddr)
+static bool ext2_ljj_check_page(struct page *page, int quiet, char *kaddr)
 {
 	struct inode *dir = page->mapping->host;
 	struct super_block *sb = dir->i_sb;
-	unsigned chunk_size = ext2_chunk_size(dir);
+	unsigned chunk_size = ext2_ljj_chunk_size(dir);
 	u32 max_inumber = le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count);
 	unsigned offs, rec_len;
 	unsigned limit = PAGE_SIZE;
-	ext2_dirent *p;
+	ext2_ljj_dirent *p;
 	char *error;
 
 	if ((dir->i_size >> PAGE_SHIFT) == page->index) {
@@ -125,8 +125,8 @@
 			goto out;
 	}
 	for (offs = 0; offs <= limit - EXT2_DIR_REC_LEN(1); offs += rec_len) {
-		p = (ext2_dirent *)(kaddr + offs);
-		rec_len = ext2_rec_len_from_disk(p->rec_len);
+		p = (ext2_ljj_dirent *)(kaddr + offs);
+		rec_len = ext2_ljj_rec_len_from_disk(p->rec_len);
 
 		if (unlikely(rec_len < EXT2_DIR_REC_LEN(1)))
 			goto Eshort;
@@ -149,7 +149,7 @@
 
 Ebadsize:
 	if (!quiet)
-		ext2_error(sb, __func__,
+		ext2_ljj_error(sb, __func__,
 			"size of directory #%lu is not a multiple "
 			"of chunk size", dir->i_ino);
 	goto fail;
@@ -169,7 +169,7 @@
 	error = "inode out of bounds";
 bad_entry:
 	if (!quiet)
-		ext2_error(sb, __func__, "bad entry in directory #%lu: : %s - "
+		ext2_ljj_error(sb, __func__, "bad entry in directory #%lu: : %s - "
 			"offset=%lu, inode=%lu, rec_len=%d, name_len=%d",
 			dir->i_ino, error, (page->index<<PAGE_SHIFT)+offs,
 			(unsigned long) le32_to_cpu(p->inode),
@@ -177,8 +177,8 @@
 	goto fail;
 Eend:
 	if (!quiet) {
-		p = (ext2_dirent *)(kaddr + offs);
-		ext2_error(sb, "ext2_check_page",
+		p = (ext2_ljj_dirent *)(kaddr + offs);
+		ext2_ljj_error(sb, "ext2_ljj_check_page",
 			"entry in directory #%lu spans the page boundary"
 			"offset=%lu, inode=%lu",
 			dir->i_ino, (page->index<<PAGE_SHIFT)+offs,
@@ -190,13 +190,13 @@
 }
 
 /*
- * Calls to ext2_get_page()/ext2_put_page() must be nested according to the
+ * Calls to ext2_ljj_get_page()/ext2_ljj_put_page() must be nested according to the
  * rules documented in kmap_local_page()/kunmap_local().
  *
- * NOTE: ext2_find_entry() and ext2_dotdot() act as a call to ext2_get_page()
- * and should be treated as a call to ext2_get_page() for nesting purposes.
+ * NOTE: ext2_ljj_find_entry() and ext2_ljj_dotdot() act as a call to ext2_ljj_get_page()
+ * and should be treated as a call to ext2_ljj_get_page() for nesting purposes.
  */
-static struct page * ext2_get_page(struct inode *dir, unsigned long n,
+static struct page * ext2_ljj_get_page(struct inode *dir, unsigned long n,
 				   int quiet, void **page_addr)
 {
 	struct address_space *mapping = dir->i_mapping;
@@ -206,23 +206,23 @@
 		return &folio->page;
 	*page_addr = kmap_local_folio(folio, n & (folio_nr_pages(folio) - 1));
 	if (unlikely(!folio_test_checked(folio))) {
-		if (!ext2_check_page(&folio->page, quiet, *page_addr))
+		if (!ext2_ljj_check_page(&folio->page, quiet, *page_addr))
 			goto fail;
 	}
 	return &folio->page;
 
 fail:
-	ext2_put_page(&folio->page, *page_addr);
+	ext2_ljj_put_page(&folio->page, *page_addr);
 	return ERR_PTR(-EIO);
 }
 
 /*
- * NOTE! unlike strncmp, ext2_match returns 1 for success, 0 for failure.
+ * NOTE! unlike strncmp, ext2_ljj_match returns 1 for success, 0 for failure.
  *
  * len <= EXT2_NAME_LEN and de != NULL are guaranteed by caller.
  */
-static inline int ext2_match (int len, const char * const name,
-					struct ext2_dir_entry_2 * de)
+static inline int ext2_ljj_match (int len, const char * const name,
+					struct ext2_ljj_dir_entry_2 * de)
 {
 	if (len != de->name_len)
 		return 0;
@@ -234,26 +234,26 @@
 /*
  * p is at least 6 bytes before the end of page
  */
-static inline ext2_dirent *ext2_next_entry(ext2_dirent *p)
+static inline ext2_ljj_dirent *ext2_ljj_next_entry(ext2_ljj_dirent *p)
 {
-	return (ext2_dirent *)((char *)p +
-			ext2_rec_len_from_disk(p->rec_len));
+	return (ext2_ljj_dirent *)((char *)p +
+			ext2_ljj_rec_len_from_disk(p->rec_len));
 }
 
 static inline unsigned 
-ext2_validate_entry(char *base, unsigned offset, unsigned mask)
+ext2_ljj_validate_entry(char *base, unsigned offset, unsigned mask)
 {
-	ext2_dirent *de = (ext2_dirent*)(base + offset);
-	ext2_dirent *p = (ext2_dirent*)(base + (offset&mask));
+	ext2_ljj_dirent *de = (ext2_ljj_dirent*)(base + offset);
+	ext2_ljj_dirent *p = (ext2_ljj_dirent*)(base + (offset&mask));
 	while ((char*)p < (char*)de) {
 		if (p->rec_len == 0)
 			break;
-		p = ext2_next_entry(p);
+		p = ext2_ljj_next_entry(p);
 	}
 	return (char *)p - base;
 }
 
-static inline void ext2_set_de_type(ext2_dirent *de, struct inode *inode)
+static inline void ext2_ljj_set_de_type(ext2_ljj_dirent *de, struct inode *inode)
 {
 	if (EXT2_HAS_INCOMPAT_FEATURE(inode->i_sb, EXT2_FEATURE_INCOMPAT_FILETYPE))
 		de->file_type = fs_umode_to_ftype(inode->i_mode);
@@ -262,7 +262,7 @@
 }
 
 static int
-ext2_readdir(struct file *file, struct dir_context *ctx)
+ext2_ljj_readdir(struct file *file, struct dir_context *ctx)
 {
 	loff_t pos = ctx->pos;
 	struct inode *inode = file_inode(file);
@@ -270,7 +270,7 @@
 	unsigned int offset = pos & ~PAGE_MASK;
 	unsigned long n = pos >> PAGE_SHIFT;
 	unsigned long npages = dir_pages(inode);
-	unsigned chunk_mask = ~(ext2_chunk_size(inode)-1);
+	unsigned chunk_mask = ~(ext2_ljj_chunk_size(inode)-1);
 	bool need_revalidate = !inode_eq_iversion(inode, file->f_version);
 	bool has_filetype;
 
@@ -282,11 +282,11 @@
 
 	for ( ; n < npages; n++, offset = 0) {
 		char *kaddr, *limit;
-		ext2_dirent *de;
-		struct page *page = ext2_get_page(inode, n, 0, (void **)&kaddr);
+		ext2_ljj_dirent *de;
+		struct page *page = ext2_ljj_get_page(inode, n, 0, (void **)&kaddr);
 
 		if (IS_ERR(page)) {
-			ext2_error(sb, __func__,
+			ext2_ljj_error(sb, __func__,
 				   "bad page in #%lu",
 				   inode->i_ino);
 			ctx->pos += PAGE_SIZE - offset;
@@ -294,19 +294,19 @@
 		}
 		if (unlikely(need_revalidate)) {
 			if (offset) {
-				offset = ext2_validate_entry(kaddr, offset, chunk_mask);
+				offset = ext2_ljj_validate_entry(kaddr, offset, chunk_mask);
 				ctx->pos = (n<<PAGE_SHIFT) + offset;
 			}
 			file->f_version = inode_query_iversion(inode);
 			need_revalidate = false;
 		}
-		de = (ext2_dirent *)(kaddr+offset);
-		limit = kaddr + ext2_last_byte(inode, n) - EXT2_DIR_REC_LEN(1);
-		for ( ;(char*)de <= limit; de = ext2_next_entry(de)) {
+		de = (ext2_ljj_dirent *)(kaddr+offset);
+		limit = kaddr + ext2_ljj_last_byte(inode, n) - EXT2_DIR_REC_LEN(1);
+		for ( ;(char*)de <= limit; de = ext2_ljj_next_entry(de)) {
 			if (de->rec_len == 0) {
-				ext2_error(sb, __func__,
+				ext2_ljj_error(sb, __func__,
 					"zero-length directory entry");
-				ext2_put_page(page, kaddr);
+				ext2_ljj_put_page(page, kaddr);
 				return -EIO;
 			}
 			if (de->inode) {
@@ -318,34 +318,34 @@
 				if (!dir_emit(ctx, de->name, de->name_len,
 						le32_to_cpu(de->inode),
 						d_type)) {
-					ext2_put_page(page, kaddr);
+					ext2_ljj_put_page(page, kaddr);
 					return 0;
 				}
 			}
-			ctx->pos += ext2_rec_len_from_disk(de->rec_len);
+			ctx->pos += ext2_ljj_rec_len_from_disk(de->rec_len);
 		}
-		ext2_put_page(page, kaddr);
+		ext2_ljj_put_page(page, kaddr);
 	}
 	return 0;
 }
 
 /*
- *	ext2_find_entry()
+ *	ext2_ljj_find_entry()
  *
  * finds an entry in the specified directory with the wanted name. It
  * returns the page in which the entry was found (as a parameter - res_page),
  * and the entry itself. Page is returned mapped and unlocked.
  * Entry is guaranteed to be valid.
  *
- * On Success ext2_put_page() should be called on *res_page.
+ * On Success ext2_ljj_put_page() should be called on *res_page.
  *
- * NOTE: Calls to ext2_get_page()/ext2_put_page() must be nested according to
+ * NOTE: Calls to ext2_ljj_get_page()/ext2_ljj_put_page() must be nested according to
  * the rules documented in kmap_local_page()/kunmap_local().
  *
- * ext2_find_entry() and ext2_dotdot() act as a call to ext2_get_page() and
- * should be treated as a call to ext2_get_page() for nesting purposes.
+ * ext2_ljj_find_entry() and ext2_ljj_dotdot() act as a call to ext2_ljj_get_page() and
+ * should be treated as a call to ext2_ljj_get_page() for nesting purposes.
  */
-struct ext2_dir_entry_2 *ext2_find_entry (struct inode *dir,
+struct ext2_ljj_dir_entry_2 *ext2_ljj_find_entry (struct inode *dir,
 			const struct qstr *child, struct page **res_page,
 			void **res_page_addr)
 {
@@ -355,8 +355,8 @@
 	unsigned long start, n;
 	unsigned long npages = dir_pages(dir);
 	struct page *page = NULL;
-	struct ext2_inode_info *ei = EXT2_I(dir);
-	ext2_dirent * de;
+	struct ext2_ljj_inode_info *ei = EXT2_I(dir);
+	ext2_ljj_dirent * de;
 	void *page_addr;
 
 	if (npages == 0)
@@ -372,31 +372,31 @@
 	n = start;
 	do {
 		char *kaddr;
-		page = ext2_get_page(dir, n, 0, &page_addr);
+		page = ext2_ljj_get_page(dir, n, 0, &page_addr);
 		if (IS_ERR(page))
 			return ERR_CAST(page);
 
 		kaddr = page_addr;
-		de = (ext2_dirent *) kaddr;
-		kaddr += ext2_last_byte(dir, n) - reclen;
+		de = (ext2_ljj_dirent *) kaddr;
+		kaddr += ext2_ljj_last_byte(dir, n) - reclen;
 		while ((char *) de <= kaddr) {
 			if (de->rec_len == 0) {
-				ext2_error(dir->i_sb, __func__,
+				ext2_ljj_error(dir->i_sb, __func__,
 					"zero-length directory entry");
-				ext2_put_page(page, page_addr);
+				ext2_ljj_put_page(page, page_addr);
 				goto out;
 			}
-			if (ext2_match(namelen, name, de))
+			if (ext2_ljj_match(namelen, name, de))
 				goto found;
-			de = ext2_next_entry(de);
+			de = ext2_ljj_next_entry(de);
 		}
-		ext2_put_page(page, page_addr);
+		ext2_ljj_put_page(page, page_addr);
 
 		if (++n >= npages)
 			n = 0;
 		/* next page is past the blocks we've got */
 		if (unlikely(n > (dir->i_blocks >> (PAGE_SHIFT - 9)))) {
-			ext2_error(dir->i_sb, __func__,
+			ext2_ljj_error(dir->i_sb, __func__,
 				"dir %lu size %lld exceeds block count %llu",
 				dir->i_ino, dir->i_size,
 				(unsigned long long)dir->i_blocks);
@@ -417,64 +417,64 @@
  * Return the '..' directory entry and the page in which the entry was found
  * (as a parameter - p).
  *
- * On Success ext2_put_page() should be called on *p.
+ * On Success ext2_ljj_put_page() should be called on *p.
  *
- * NOTE: Calls to ext2_get_page()/ext2_put_page() must be nested according to
+ * NOTE: Calls to ext2_ljj_get_page()/ext2_ljj_put_page() must be nested according to
  * the rules documented in kmap_local_page()/kunmap_local().
  *
- * ext2_find_entry() and ext2_dotdot() act as a call to ext2_get_page() and
- * should be treated as a call to ext2_get_page() for nesting purposes.
+ * ext2_ljj_find_entry() and ext2_ljj_dotdot() act as a call to ext2_ljj_get_page() and
+ * should be treated as a call to ext2_ljj_get_page() for nesting purposes.
  */
-struct ext2_dir_entry_2 *ext2_dotdot(struct inode *dir, struct page **p,
+struct ext2_ljj_dir_entry_2 *ext2_ljj_dotdot(struct inode *dir, struct page **p,
 				     void **pa)
 {
 	void *page_addr;
-	struct page *page = ext2_get_page(dir, 0, 0, &page_addr);
-	ext2_dirent *de = NULL;
+	struct page *page = ext2_ljj_get_page(dir, 0, 0, &page_addr);
+	ext2_ljj_dirent *de = NULL;
 
 	if (!IS_ERR(page)) {
-		de = ext2_next_entry((ext2_dirent *) page_addr);
+		de = ext2_ljj_next_entry((ext2_ljj_dirent *) page_addr);
 		*p = page;
 		*pa = page_addr;
 	}
 	return de;
 }
 
-int ext2_inode_by_name(struct inode *dir, const struct qstr *child, ino_t *ino)
+int ext2_ljj_inode_by_name(struct inode *dir, const struct qstr *child, ino_t *ino)
 {
-	struct ext2_dir_entry_2 *de;
+	struct ext2_ljj_dir_entry_2 *de;
 	struct page *page;
 	void *page_addr;
 	
-	de = ext2_find_entry(dir, child, &page, &page_addr);
+	de = ext2_ljj_find_entry(dir, child, &page, &page_addr);
 	if (IS_ERR(de))
 		return PTR_ERR(de);
 
 	*ino = le32_to_cpu(de->inode);
-	ext2_put_page(page, page_addr);
+	ext2_ljj_put_page(page, page_addr);
 	return 0;
 }
 
-static int ext2_prepare_chunk(struct page *page, loff_t pos, unsigned len)
+static int ext2_ljj_prepare_chunk(struct page *page, loff_t pos, unsigned len)
 {
-	return __block_write_begin(page, pos, len, ext2_get_block);
+	return __block_write_begin(page, pos, len, ext2_ljj_get_block);
 }
 
-void ext2_set_link(struct inode *dir, struct ext2_dir_entry_2 *de,
+void ext2_ljj_set_link(struct inode *dir, struct ext2_ljj_dir_entry_2 *de,
 		   struct page *page, void *page_addr, struct inode *inode,
 		   int update_times)
 {
 	loff_t pos = page_offset(page) +
 			(char *) de - (char *) page_addr;
-	unsigned len = ext2_rec_len_from_disk(de->rec_len);
+	unsigned len = ext2_ljj_rec_len_from_disk(de->rec_len);
 	int err;
 
 	lock_page(page);
-	err = ext2_prepare_chunk(page, pos, len);
+	err = ext2_ljj_prepare_chunk(page, pos, len);
 	BUG_ON(err);
 	de->inode = cpu_to_le32(inode->i_ino);
-	ext2_set_de_type(de, inode);
-	err = ext2_commit_chunk(page, pos, len);
+	ext2_ljj_set_de_type(de, inode);
+	err = ext2_ljj_commit_chunk(page, pos, len);
 	if (update_times)
 		dir->i_mtime = dir->i_ctime = current_time(dir);
 	EXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;
@@ -484,17 +484,17 @@
 /*
  *	Parent is locked.
  */
-int ext2_add_link (struct dentry *dentry, struct inode *inode)
+int ext2_ljj_add_link (struct dentry *dentry, struct inode *inode)
 {
 	struct inode *dir = d_inode(dentry->d_parent);
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
-	unsigned chunk_size = ext2_chunk_size(dir);
+	unsigned chunk_size = ext2_ljj_chunk_size(dir);
 	unsigned reclen = EXT2_DIR_REC_LEN(namelen);
 	unsigned short rec_len, name_len;
 	struct page *page = NULL;
 	void *page_addr = NULL;
-	ext2_dirent * de;
+	ext2_ljj_dirent * de;
 	unsigned long npages = dir_pages(dir);
 	unsigned long n;
 	loff_t pos;
@@ -509,43 +509,43 @@
 		char *kaddr;
 		char *dir_end;
 
-		page = ext2_get_page(dir, n, 0, &page_addr);
+		page = ext2_ljj_get_page(dir, n, 0, &page_addr);
 		err = PTR_ERR(page);
 		if (IS_ERR(page))
 			goto out;
 		lock_page(page);
 		kaddr = page_addr;
-		dir_end = kaddr + ext2_last_byte(dir, n);
-		de = (ext2_dirent *)kaddr;
+		dir_end = kaddr + ext2_ljj_last_byte(dir, n);
+		de = (ext2_ljj_dirent *)kaddr;
 		kaddr += PAGE_SIZE - reclen;
 		while ((char *)de <= kaddr) {
 			if ((char *)de == dir_end) {
 				/* We hit i_size */
 				name_len = 0;
 				rec_len = chunk_size;
-				de->rec_len = ext2_rec_len_to_disk(chunk_size);
+				de->rec_len = ext2_ljj_rec_len_to_disk(chunk_size);
 				de->inode = 0;
 				goto got_it;
 			}
 			if (de->rec_len == 0) {
-				ext2_error(dir->i_sb, __func__,
+				ext2_ljj_error(dir->i_sb, __func__,
 					"zero-length directory entry");
 				err = -EIO;
 				goto out_unlock;
 			}
 			err = -EEXIST;
-			if (ext2_match (namelen, name, de))
+			if (ext2_ljj_match (namelen, name, de))
 				goto out_unlock;
 			name_len = EXT2_DIR_REC_LEN(de->name_len);
-			rec_len = ext2_rec_len_from_disk(de->rec_len);
+			rec_len = ext2_ljj_rec_len_from_disk(de->rec_len);
 			if (!de->inode && rec_len >= reclen)
 				goto got_it;
 			if (rec_len >= name_len + reclen)
 				goto got_it;
-			de = (ext2_dirent *) ((char *) de + rec_len);
+			de = (ext2_ljj_dirent *) ((char *) de + rec_len);
 		}
 		unlock_page(page);
-		ext2_put_page(page, page_addr);
+		ext2_ljj_put_page(page, page_addr);
 	}
 	BUG();
 	return -EINVAL;
@@ -553,26 +553,26 @@
 got_it:
 	pos = page_offset(page) +
 		(char *)de - (char *)page_addr;
-	err = ext2_prepare_chunk(page, pos, rec_len);
+	err = ext2_ljj_prepare_chunk(page, pos, rec_len);
 	if (err)
 		goto out_unlock;
 	if (de->inode) {
-		ext2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);
-		de1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);
-		de->rec_len = ext2_rec_len_to_disk(name_len);
+		ext2_ljj_dirent *de1 = (ext2_ljj_dirent *) ((char *) de + name_len);
+		de1->rec_len = ext2_ljj_rec_len_to_disk(rec_len - name_len);
+		de->rec_len = ext2_ljj_rec_len_to_disk(name_len);
 		de = de1;
 	}
 	de->name_len = namelen;
 	memcpy(de->name, name, namelen);
 	de->inode = cpu_to_le32(inode->i_ino);
-	ext2_set_de_type (de, inode);
-	err = ext2_commit_chunk(page, pos, rec_len);
+	ext2_ljj_set_de_type (de, inode);
+	err = ext2_ljj_commit_chunk(page, pos, rec_len);
 	dir->i_mtime = dir->i_ctime = current_time(dir);
 	EXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;
 	mark_inode_dirty(dir);
 	/* OFFSET_CACHE */
 out_put:
-	ext2_put_page(page, page_addr);
+	ext2_ljj_put_page(page, page_addr);
 out:
 	return err;
 out_unlock:
@@ -581,41 +581,41 @@
 }
 
 /*
- * ext2_delete_entry deletes a directory entry by merging it with the
+ * ext2_ljj_delete_entry deletes a directory entry by merging it with the
  * previous entry. Page is up-to-date.
  */
-int ext2_delete_entry (struct ext2_dir_entry_2 *dir, struct page *page,
+int ext2_ljj_delete_entry (struct ext2_ljj_dir_entry_2 *dir, struct page *page,
 			char *kaddr)
 {
 	struct inode *inode = page->mapping->host;
-	unsigned from = ((char*)dir - kaddr) & ~(ext2_chunk_size(inode)-1);
+	unsigned from = ((char*)dir - kaddr) & ~(ext2_ljj_chunk_size(inode)-1);
 	unsigned to = ((char *)dir - kaddr) +
-				ext2_rec_len_from_disk(dir->rec_len);
+				ext2_ljj_rec_len_from_disk(dir->rec_len);
 	loff_t pos;
-	ext2_dirent * pde = NULL;
-	ext2_dirent * de = (ext2_dirent *) (kaddr + from);
+	ext2_ljj_dirent * pde = NULL;
+	ext2_ljj_dirent * de = (ext2_ljj_dirent *) (kaddr + from);
 	int err;
 
 	while ((char*)de < (char*)dir) {
 		if (de->rec_len == 0) {
-			ext2_error(inode->i_sb, __func__,
+			ext2_ljj_error(inode->i_sb, __func__,
 				"zero-length directory entry");
 			err = -EIO;
 			goto out;
 		}
 		pde = de;
-		de = ext2_next_entry(de);
+		de = ext2_ljj_next_entry(de);
 	}
 	if (pde)
 		from = (char *)pde - kaddr;
 	pos = page_offset(page) + from;
 	lock_page(page);
-	err = ext2_prepare_chunk(page, pos, to - from);
+	err = ext2_ljj_prepare_chunk(page, pos, to - from);
 	BUG_ON(err);
 	if (pde)
-		pde->rec_len = ext2_rec_len_to_disk(to - from);
+		pde->rec_len = ext2_ljj_rec_len_to_disk(to - from);
 	dir->inode = 0;
-	err = ext2_commit_chunk(page, pos, to - from);
+	err = ext2_ljj_commit_chunk(page, pos, to - from);
 	inode->i_ctime = inode->i_mtime = current_time(inode);
 	EXT2_I(inode)->i_flags &= ~EXT2_BTREE_FL;
 	mark_inode_dirty(inode);
@@ -626,39 +626,39 @@
 /*
  * Set the first fragment of directory.
  */
-int ext2_make_empty(struct inode *inode, struct inode *parent)
+int ext2_ljj_make_empty(struct inode *inode, struct inode *parent)
 {
 	struct page *page = grab_cache_page(inode->i_mapping, 0);
-	unsigned chunk_size = ext2_chunk_size(inode);
-	struct ext2_dir_entry_2 * de;
+	unsigned chunk_size = ext2_ljj_chunk_size(inode);
+	struct ext2_ljj_dir_entry_2 * de;
 	int err;
 	void *kaddr;
 
 	if (!page)
 		return -ENOMEM;
 
-	err = ext2_prepare_chunk(page, 0, chunk_size);
+	err = ext2_ljj_prepare_chunk(page, 0, chunk_size);
 	if (err) {
 		unlock_page(page);
 		goto fail;
 	}
 	kaddr = kmap_atomic(page);
 	memset(kaddr, 0, chunk_size);
-	de = (struct ext2_dir_entry_2 *)kaddr;
+	de = (struct ext2_ljj_dir_entry_2 *)kaddr;
 	de->name_len = 1;
-	de->rec_len = ext2_rec_len_to_disk(EXT2_DIR_REC_LEN(1));
+	de->rec_len = ext2_ljj_rec_len_to_disk(EXT2_DIR_REC_LEN(1));
 	memcpy (de->name, ".\0\0", 4);
 	de->inode = cpu_to_le32(inode->i_ino);
-	ext2_set_de_type (de, inode);
+	ext2_ljj_set_de_type (de, inode);
 
-	de = (struct ext2_dir_entry_2 *)(kaddr + EXT2_DIR_REC_LEN(1));
+	de = (struct ext2_ljj_dir_entry_2 *)(kaddr + EXT2_DIR_REC_LEN(1));
 	de->name_len = 2;
-	de->rec_len = ext2_rec_len_to_disk(chunk_size - EXT2_DIR_REC_LEN(1));
+	de->rec_len = ext2_ljj_rec_len_to_disk(chunk_size - EXT2_DIR_REC_LEN(1));
 	de->inode = cpu_to_le32(parent->i_ino);
 	memcpy (de->name, "..\0", 4);
-	ext2_set_de_type (de, inode);
+	ext2_ljj_set_de_type (de, inode);
 	kunmap_atomic(kaddr);
-	err = ext2_commit_chunk(page, 0, chunk_size);
+	err = ext2_ljj_commit_chunk(page, 0, chunk_size);
 fail:
 	put_page(page);
 	return err;
@@ -667,7 +667,7 @@
 /*
  * routine to check that the specified directory is empty (for rmdir)
  */
-int ext2_empty_dir (struct inode * inode)
+int ext2_ljj_empty_dir (struct inode * inode)
 {
 	void *page_addr = NULL;
 	struct page *page = NULL;
@@ -675,19 +675,19 @@
 
 	for (i = 0; i < npages; i++) {
 		char *kaddr;
-		ext2_dirent * de;
-		page = ext2_get_page(inode, i, 0, &page_addr);
+		ext2_ljj_dirent * de;
+		page = ext2_ljj_get_page(inode, i, 0, &page_addr);
 
 		if (IS_ERR(page))
 			return 0;
 
 		kaddr = page_addr;
-		de = (ext2_dirent *)kaddr;
-		kaddr += ext2_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);
+		de = (ext2_ljj_dirent *)kaddr;
+		kaddr += ext2_ljj_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);
 
 		while ((char *)de <= kaddr) {
 			if (de->rec_len == 0) {
-				ext2_error(inode->i_sb, __func__,
+				ext2_ljj_error(inode->i_sb, __func__,
 					"zero-length directory entry");
 				printk("kaddr=%p, de=%p\n", kaddr, de);
 				goto not_empty;
@@ -705,24 +705,24 @@
 				} else if (de->name[1] != '.')
 					goto not_empty;
 			}
-			de = ext2_next_entry(de);
+			de = ext2_ljj_next_entry(de);
 		}
-		ext2_put_page(page, page_addr);
+		ext2_ljj_put_page(page, page_addr);
 	}
 	return 1;
 
 not_empty:
-	ext2_put_page(page, page_addr);
+	ext2_ljj_put_page(page, page_addr);
 	return 0;
 }
 
-const struct file_operations ext2_dir_operations = {
+const struct file_operations ext2_ljj_dir_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
-	.iterate_shared	= ext2_readdir,
-	.unlocked_ioctl = ext2_ioctl,
+	.iterate_shared	= ext2_ljj_readdir,
+	.unlocked_ioctl = ext2_ljj_ioctl,
 #ifdef CONFIG_COMPAT
-	.compat_ioctl	= ext2_compat_ioctl,
+	.compat_ioctl	= ext2_ljj_compat_ioctl,
 #endif
-	.fsync		= ext2_fsync,
+	.fsync		= ext2_ljj_fsync,
 };
diff -urN fs/ext2/ext2.h fs/ext2_ljj/ext2.h
--- fs/ext2/ext2.h	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/ext2.h	2024-11-04 11:48:27.263697050 +0800
@@ -12,7 +12,7 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 #include <linux/fs.h>
-#include <linux/ext2_fs.h>
+#include <linux/ext2_ljj_fs.h>
 #include <linux/blockgroup_lock.h>
 #include <linux/percpu_counter.h>
 #include <linux/rbtree.h>
@@ -22,43 +22,43 @@
 /* XXX Here for now... not interested in restructing headers JUST now */
 
 /* data type for block offset of block group */
-typedef int ext2_grpblk_t;
+typedef int ext2_ljj_grpblk_t;
 
 /* data type for filesystem-wide blocks number */
-typedef unsigned long ext2_fsblk_t;
+typedef unsigned long ext2_ljj_fsblk_t;
 
 #define E2FSBLK "%lu"
 
-struct ext2_reserve_window {
-	ext2_fsblk_t		_rsv_start;	/* First byte reserved */
-	ext2_fsblk_t		_rsv_end;	/* Last byte reserved or 0 */
+struct ext2_ljj_reserve_window {
+	ext2_ljj_fsblk_t		_rsv_start;	/* First byte reserved */
+	ext2_ljj_fsblk_t		_rsv_end;	/* Last byte reserved or 0 */
 };
 
-struct ext2_reserve_window_node {
+struct ext2_ljj_reserve_window_node {
 	struct rb_node	 	rsv_node;
 	__u32			rsv_goal_size;
 	__u32			rsv_alloc_hit;
-	struct ext2_reserve_window	rsv_window;
+	struct ext2_ljj_reserve_window	rsv_window;
 };
 
-struct ext2_block_alloc_info {
+struct ext2_ljj_block_alloc_info {
 	/* information about reservation window */
-	struct ext2_reserve_window_node	rsv_window_node;
+	struct ext2_ljj_reserve_window_node	rsv_window_node;
 	/*
-	 * was i_next_alloc_block in ext2_inode_info
+	 * was i_next_alloc_block in ext2_ljj_inode_info
 	 * is the logical (file-relative) number of the
 	 * most-recently-allocated block in this file.
 	 * We use this for detecting linearly ascending allocation requests.
 	 */
 	__u32			last_alloc_logical_block;
 	/*
-	 * Was i_next_alloc_goal in ext2_inode_info
+	 * Was i_next_alloc_goal in ext2_ljj_inode_info
 	 * is the *physical* companion to i_next_alloc_block.
 	 * it is the physical block number of the block which was most-recently
 	 * allocated to this file.  This gives us the goal (target) for the next
 	 * allocation when we detect linearly ascending requests.
 	 */
-	ext2_fsblk_t		last_alloc_physical_block;
+	ext2_ljj_fsblk_t		last_alloc_physical_block;
 };
 
 #define rsv_start rsv_window._rsv_start
@@ -69,7 +69,7 @@
 /*
  * second extended-fs super-block data in memory
  */
-struct ext2_sb_info {
+struct ext2_ljj_sb_info {
 	unsigned long s_inodes_per_block;/* Number of inodes per block */
 	unsigned long s_blocks_per_group;/* Number of blocks in a group */
 	unsigned long s_inodes_per_group;/* Number of inodes in a group */
@@ -80,7 +80,7 @@
 	unsigned long s_overhead_last;  /* Last calculated overhead */
 	unsigned long s_blocks_last;    /* Last seen block count */
 	struct buffer_head * s_sbh;	/* Buffer containing the super block */
-	struct ext2_super_block * s_es;	/* Pointer to the super block in the buffer */
+	struct ext2_ljj_super_block * s_es;	/* Pointer to the super block in the buffer */
 	struct buffer_head ** s_group_desc;
 	unsigned long  s_mount_opt;
 	unsigned long s_sb_block;
@@ -103,13 +103,13 @@
 	/* root of the per fs reservation window tree */
 	spinlock_t s_rsv_window_lock;
 	struct rb_root s_rsv_window_root;
-	struct ext2_reserve_window_node s_rsv_window_head;
+	struct ext2_ljj_reserve_window_node s_rsv_window_head;
 	/*
 	 * s_lock protects against concurrent modifications of s_mount_state,
 	 * s_blocks_last, s_overhead_last and the content of superblock's
 	 * buffer pointed to by sbi->s_es.
 	 *
-	 * Note: It is used in ext2_show_options() to provide a consistent view
+	 * Note: It is used in ext2_ljj_show_options() to provide a consistent view
 	 * of the mount options.
 	 */
 	spinlock_t s_lock;
@@ -119,7 +119,7 @@
 };
 
 static inline spinlock_t *
-sb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)
+sb_bgl_lock(struct ext2_ljj_sb_info *sbi, unsigned int block_group)
 {
 	return bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);
 }
@@ -146,13 +146,13 @@
  * Debug code
  */
 #ifdef EXT2FS_DEBUG
-#	define ext2_debug(f, a...)	{ \
+#	define ext2_ljj_debug(f, a...)	{ \
 					printk ("EXT2-fs DEBUG (%s, %d): %s:", \
 						__FILE__, __LINE__, __func__); \
 				  	printk (f, ## a); \
 					}
 #else
-#	define ext2_debug(f, a...)	/**/
+#	define ext2_ljj_debug(f, a...)	/**/
 #endif
 
 /*
@@ -163,10 +163,10 @@
 #define EXT2_BOOT_LOADER_INO	 5	/* Boot loader inode */
 #define EXT2_UNDEL_DIR_INO	 6	/* Undelete directory inode */
 
-/* First non-reserved inode for old ext2 filesystems */
+/* First non-reserved inode for old ext2_ljj filesystems */
 #define EXT2_GOOD_OLD_FIRST_INO	11
 
-static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)
+static inline struct ext2_ljj_sb_info *EXT2_SB(struct super_block *sb)
 {
 	return sb->s_fs_info;
 }
@@ -188,7 +188,7 @@
 /*
  * Structure of a blocks group descriptor
  */
-struct ext2_group_desc
+struct ext2_ljj_group_desc
 {
 	__le32	bg_block_bitmap;		/* Blocks bitmap block */
 	__le32	bg_inode_bitmap;		/* Inodes bitmap block */
@@ -241,7 +241,7 @@
 #define EXT2_NOTAIL_FL			FS_NOTAIL_FL	/* file tail should not be merged */
 #define EXT2_DIRSYNC_FL			FS_DIRSYNC_FL	/* dirsync behaviour (directories only) */
 #define EXT2_TOPDIR_FL			FS_TOPDIR_FL	/* Top of directory hierarchies*/
-#define EXT2_RESERVED_FL		FS_RESERVED_FL	/* reserved for ext2 lib */
+#define EXT2_RESERVED_FL		FS_RESERVED_FL	/* reserved for ext2_ljj lib */
 
 #define EXT2_FL_USER_VISIBLE		FS_FL_USER_VISIBLE	/* User visible flags */
 #define EXT2_FL_USER_MODIFIABLE		FS_FL_USER_MODIFIABLE	/* User modifiable flags */
@@ -260,7 +260,7 @@
 #define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)
 
 /* Mask out flags that are inappropriate for the given type of inode. */
-static inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)
+static inline __u32 ext2_ljj_mask_flags(umode_t mode, __u32 flags)
 {
 	if (S_ISDIR(mode))
 		return flags;
@@ -287,7 +287,7 @@
 /*
  * Structure of an inode on the disk
  */
-struct ext2_inode {
+struct ext2_ljj_inode {
 	__le16	i_mode;		/* File mode */
 	__le16	i_uid;		/* Low 16 bits of Owner Uid */
 	__le32	i_size;		/* Size in bytes */
@@ -401,7 +401,7 @@
 /*
  * Structure of the super block
  */
-struct ext2_super_block {
+struct ext2_ljj_super_block {
 	__le32	s_inodes_count;		/* Inodes count */
 	__le32	s_blocks_count;		/* Blocks count */
 	__le32	s_r_blocks_count;	/* Reserved blocks count */
@@ -559,7 +559,7 @@
 #define EXT2_DEFM_XATTR_USER	0x0004
 #define EXT2_DEFM_ACL		0x0008
 #define EXT2_DEFM_UID16		0x0010
-    /* Not used by ext2, but reserved for use by ext3 */
+    /* Not used by ext2_ljj, but reserved for use by ext3 */
 #define EXT3_DEFM_JMODE		0x0060 
 #define EXT3_DEFM_JMODE_DATA	0x0020
 #define EXT3_DEFM_JMODE_ORDERED	0x0040
@@ -569,7 +569,7 @@
  * Structure of a directory entry
  */
 
-struct ext2_dir_entry {
+struct ext2_ljj_dir_entry {
 	__le32	inode;			/* Inode number */
 	__le16	rec_len;		/* Directory entry length */
 	__le16	name_len;		/* Name length */
@@ -582,7 +582,7 @@
  * bigger than 255 chars, it's safe to reclaim the extra byte for the
  * file_type field.
  */
-struct ext2_dir_entry_2 {
+struct ext2_ljj_dir_entry_2 {
 	__le32	inode;			/* Inode number */
 	__le16	rec_len;		/* Directory entry length */
 	__u8	name_len;		/* Name length */
@@ -603,7 +603,7 @@
 
 static inline void verify_offsets(void)
 {
-#define A(x,y) BUILD_BUG_ON(x != offsetof(struct ext2_super_block, y));
+#define A(x,y) BUILD_BUG_ON(x != offsetof(struct ext2_ljj_super_block, y));
 	A(EXT2_SB_MAGIC_OFFSET, s_magic);
 	A(EXT2_SB_BLOCKS_OFFSET, s_blocks_count);
 	A(EXT2_SB_BSIZE_OFFSET, s_log_block_size);
@@ -611,9 +611,9 @@
 }
 
 /*
- * ext2 mount options
+ * ext2_ljj mount options
  */
-struct ext2_mount_options {
+struct ext2_ljj_mount_options {
 	unsigned long s_mount_opt;
 	kuid_t s_resuid;
 	kgid_t s_resgid;
@@ -622,7 +622,7 @@
 /*
  * second extended file system inode data in memory
  */
-struct ext2_inode_info {
+struct ext2_ljj_inode_info {
 	__le32	i_data[15];
 	__u32	i_flags;
 	__u32	i_faddr;
@@ -643,7 +643,7 @@
 	__u32	i_block_group;
 
 	/* block reservation info */
-	struct ext2_block_alloc_info *i_block_alloc_info;
+	struct ext2_ljj_block_alloc_info *i_block_alloc_info;
 
 	__u32	i_dir_start_lookup;
 #ifdef CONFIG_EXT2_FS_XATTR
@@ -659,10 +659,10 @@
 	rwlock_t i_meta_lock;
 
 	/*
-	 * truncate_mutex is for serialising ext2_truncate() against
-	 * ext2_getblock().  It also protects the internals of the inode's
-	 * reservation data structures: ext2_reserve_window and
-	 * ext2_reserve_window_node.
+	 * truncate_mutex is for serialising ext2_ljj_truncate() against
+	 * ext2_ljj_getblock().  It also protects the internals of the inode's
+	 * reservation data structures: ext2_ljj_reserve_window and
+	 * ext2_ljj_reserve_window_node.
 	 */
 	struct mutex truncate_mutex;
 	struct inode	vfs_inode;
@@ -684,88 +684,88 @@
 
 /*
  * Ok, these declarations are also in <linux/kernel.h> but none of the
- * ext2 source programs needs to include it so they are duplicated here.
+ * ext2_ljj source programs needs to include it so they are duplicated here.
  */
 
-static inline struct ext2_inode_info *EXT2_I(struct inode *inode)
+static inline struct ext2_ljj_inode_info *EXT2_I(struct inode *inode)
 {
-	return container_of(inode, struct ext2_inode_info, vfs_inode);
+	return container_of(inode, struct ext2_ljj_inode_info, vfs_inode);
 }
 
 /* balloc.c */
-extern int ext2_bg_has_super(struct super_block *sb, int group);
-extern unsigned long ext2_bg_num_gdb(struct super_block *sb, int group);
-extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);
-extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,
+extern int ext2_ljj_bg_has_super(struct super_block *sb, int group);
+extern unsigned long ext2_ljj_bg_num_gdb(struct super_block *sb, int group);
+extern ext2_ljj_fsblk_t ext2_ljj_new_block(struct inode *, unsigned long, int *);
+extern ext2_ljj_fsblk_t ext2_ljj_new_blocks(struct inode *, unsigned long,
 				unsigned long *, int *);
-extern int ext2_data_block_valid(struct ext2_sb_info *sbi, ext2_fsblk_t start_blk,
+extern int ext2_ljj_data_block_valid(struct ext2_ljj_sb_info *sbi, ext2_ljj_fsblk_t start_blk,
 				 unsigned int count);
-extern void ext2_free_blocks (struct inode *, unsigned long,
+extern void ext2_ljj_free_blocks (struct inode *, unsigned long,
 			      unsigned long);
-extern unsigned long ext2_count_free_blocks (struct super_block *);
-extern unsigned long ext2_count_dirs (struct super_block *);
-extern struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,
+extern unsigned long ext2_ljj_count_free_blocks (struct super_block *);
+extern unsigned long ext2_ljj_count_dirs (struct super_block *);
+extern struct ext2_ljj_group_desc * ext2_ljj_get_group_desc(struct super_block * sb,
 						    unsigned int block_group,
 						    struct buffer_head ** bh);
-extern void ext2_discard_reservation (struct inode *);
-extern int ext2_should_retry_alloc(struct super_block *sb, int *retries);
-extern void ext2_init_block_alloc_info(struct inode *);
-extern void ext2_rsv_window_add(struct super_block *sb, struct ext2_reserve_window_node *rsv);
+extern void ext2_ljj_discard_reservation (struct inode *);
+extern int ext2_ljj_should_retry_alloc(struct super_block *sb, int *retries);
+extern void ext2_ljj_init_block_alloc_info(struct inode *);
+extern void ext2_ljj_rsv_window_add(struct super_block *sb, struct ext2_ljj_reserve_window_node *rsv);
 
 /* dir.c */
-extern int ext2_add_link (struct dentry *, struct inode *);
-extern int ext2_inode_by_name(struct inode *dir,
+extern int ext2_ljj_add_link (struct dentry *, struct inode *);
+extern int ext2_ljj_inode_by_name(struct inode *dir,
 			      const struct qstr *child, ino_t *ino);
-extern int ext2_make_empty(struct inode *, struct inode *);
-extern struct ext2_dir_entry_2 *ext2_find_entry(struct inode *, const struct qstr *,
+extern int ext2_ljj_make_empty(struct inode *, struct inode *);
+extern struct ext2_ljj_dir_entry_2 *ext2_ljj_find_entry(struct inode *, const struct qstr *,
 						struct page **, void **res_page_addr);
-extern int ext2_delete_entry(struct ext2_dir_entry_2 *dir, struct page *page,
+extern int ext2_ljj_delete_entry(struct ext2_ljj_dir_entry_2 *dir, struct page *page,
 			     char *kaddr);
-extern int ext2_empty_dir (struct inode *);
-extern struct ext2_dir_entry_2 *ext2_dotdot(struct inode *dir, struct page **p, void **pa);
-extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, void *,
+extern int ext2_ljj_empty_dir (struct inode *);
+extern struct ext2_ljj_dir_entry_2 *ext2_ljj_dotdot(struct inode *dir, struct page **p, void **pa);
+extern void ext2_ljj_set_link(struct inode *, struct ext2_ljj_dir_entry_2 *, struct page *, void *,
 			  struct inode *, int);
-static inline void ext2_put_page(struct page *page, void *page_addr)
+static inline void ext2_ljj_put_page(struct page *page, void *page_addr)
 {
 	kunmap_local(page_addr);
 	put_page(page);
 }
 
 /* ialloc.c */
-extern struct inode * ext2_new_inode (struct inode *, umode_t, const struct qstr *);
-extern void ext2_free_inode (struct inode *);
-extern unsigned long ext2_count_free_inodes (struct super_block *);
-extern unsigned long ext2_count_free (struct buffer_head *, unsigned);
+extern struct inode * ext2_ljj_new_inode (struct inode *, umode_t, const struct qstr *);
+extern void ext2_ljj_free_inode (struct inode *);
+extern unsigned long ext2_ljj_count_free_inodes (struct super_block *);
+extern unsigned long ext2_ljj_count_free (struct buffer_head *, unsigned);
 
 /* inode.c */
-extern struct inode *ext2_iget (struct super_block *, unsigned long);
-extern int ext2_write_inode (struct inode *, struct writeback_control *);
-extern void ext2_evict_inode(struct inode *);
-extern int ext2_get_block(struct inode *, sector_t, struct buffer_head *, int);
-extern int ext2_setattr (struct user_namespace *, struct dentry *, struct iattr *);
-extern int ext2_getattr (struct user_namespace *, const struct path *,
+extern struct inode *ext2_ljj_iget (struct super_block *, unsigned long);
+extern int ext2_ljj_write_inode (struct inode *, struct writeback_control *);
+extern void ext2_ljj_evict_inode(struct inode *);
+extern int ext2_ljj_get_block(struct inode *, sector_t, struct buffer_head *, int);
+extern int ext2_ljj_setattr (struct user_namespace *, struct dentry *, struct iattr *);
+extern int ext2_ljj_getattr (struct user_namespace *, const struct path *,
 			 struct kstat *, u32, unsigned int);
-extern void ext2_set_inode_flags(struct inode *inode);
-extern int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
+extern void ext2_ljj_set_inode_flags(struct inode *inode);
+extern int ext2_ljj_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 		       u64 start, u64 len);
 
 /* ioctl.c */
-extern int ext2_fileattr_get(struct dentry *dentry, struct fileattr *fa);
-extern int ext2_fileattr_set(struct user_namespace *mnt_userns,
+extern int ext2_ljj_fileattr_get(struct dentry *dentry, struct fileattr *fa);
+extern int ext2_ljj_fileattr_set(struct user_namespace *mnt_userns,
 			     struct dentry *dentry, struct fileattr *fa);
-extern long ext2_ioctl(struct file *, unsigned int, unsigned long);
-extern long ext2_compat_ioctl(struct file *, unsigned int, unsigned long);
+extern long ext2_ljj_ioctl(struct file *, unsigned int, unsigned long);
+extern long ext2_ljj_compat_ioctl(struct file *, unsigned int, unsigned long);
 
 /* namei.c */
-struct dentry *ext2_get_parent(struct dentry *child);
+struct dentry *ext2_ljj_get_parent(struct dentry *child);
 
 /* super.c */
 extern __printf(3, 4)
-void ext2_error(struct super_block *, const char *, const char *, ...);
+void ext2_ljj_error(struct super_block *, const char *, const char *, ...);
 extern __printf(3, 4)
-void ext2_msg(struct super_block *, const char *, const char *, ...);
-extern void ext2_update_dynamic_rev (struct super_block *sb);
-extern void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,
+void ext2_ljj_msg(struct super_block *, const char *, const char *, ...);
+extern void ext2_ljj_update_dynamic_rev (struct super_block *sb);
+extern void ext2_ljj_sync_super(struct super_block *sb, struct ext2_ljj_super_block *es,
 			    int wait);
 
 /*
@@ -773,48 +773,48 @@
  */
 
 /* dir.c */
-extern const struct file_operations ext2_dir_operations;
+extern const struct file_operations ext2_ljj_dir_operations;
 
 /* file.c */
-extern int ext2_fsync(struct file *file, loff_t start, loff_t end,
+extern int ext2_ljj_fsync(struct file *file, loff_t start, loff_t end,
 		      int datasync);
-extern const struct inode_operations ext2_file_inode_operations;
-extern const struct file_operations ext2_file_operations;
+extern const struct inode_operations ext2_ljj_file_inode_operations;
+extern const struct file_operations ext2_ljj_file_operations;
 
 /* inode.c */
-extern void ext2_set_file_ops(struct inode *inode);
-extern const struct address_space_operations ext2_aops;
-extern const struct iomap_ops ext2_iomap_ops;
+extern void ext2_ljj_set_file_ops(struct inode *inode);
+extern const struct address_space_operations ext2_ljj_aops;
+extern const struct iomap_ops ext2_ljj_iomap_ops;
 
 /* namei.c */
-extern const struct inode_operations ext2_dir_inode_operations;
-extern const struct inode_operations ext2_special_inode_operations;
+extern const struct inode_operations ext2_ljj_dir_inode_operations;
+extern const struct inode_operations ext2_ljj_special_inode_operations;
 
 /* symlink.c */
-extern const struct inode_operations ext2_fast_symlink_inode_operations;
-extern const struct inode_operations ext2_symlink_inode_operations;
+extern const struct inode_operations ext2_ljj_fast_symlink_inode_operations;
+extern const struct inode_operations ext2_ljj_symlink_inode_operations;
 
-static inline ext2_fsblk_t
-ext2_group_first_block_no(struct super_block *sb, unsigned long group_no)
+static inline ext2_ljj_fsblk_t
+ext2_ljj_group_first_block_no(struct super_block *sb, unsigned long group_no)
 {
-	return group_no * (ext2_fsblk_t)EXT2_BLOCKS_PER_GROUP(sb) +
+	return group_no * (ext2_ljj_fsblk_t)EXT2_BLOCKS_PER_GROUP(sb) +
 		le32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block);
 }
 
-static inline ext2_fsblk_t
-ext2_group_last_block_no(struct super_block *sb, unsigned long group_no)
+static inline ext2_ljj_fsblk_t
+ext2_ljj_group_last_block_no(struct super_block *sb, unsigned long group_no)
 {
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 
 	if (group_no == sbi->s_groups_count - 1)
 		return le32_to_cpu(sbi->s_es->s_blocks_count) - 1;
 	else
-		return ext2_group_first_block_no(sb, group_no) +
+		return ext2_ljj_group_first_block_no(sb, group_no) +
 			EXT2_BLOCKS_PER_GROUP(sb) - 1;
 }
 
-#define ext2_set_bit	__test_and_set_bit_le
-#define ext2_clear_bit	__test_and_clear_bit_le
-#define ext2_test_bit	test_bit_le
-#define ext2_find_first_zero_bit	find_first_zero_bit_le
-#define ext2_find_next_zero_bit		find_next_zero_bit_le
+#define ext2_ljj_set_bit	__test_and_set_bit_le
+#define ext2_ljj_clear_bit	__test_and_clear_bit_le
+#define ext2_ljj_test_bit	test_bit_le
+#define ext2_ljj_find_first_zero_bit	find_first_zero_bit_le
+#define ext2_ljj_find_next_zero_bit		find_next_zero_bit_le
diff -urN fs/ext2/file.c fs/ext2_ljj/file.c
--- fs/ext2/file.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/file.c	2024-11-04 11:48:27.264696979 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *  linux/fs/ext2/file.c
+ *  linux/fs/ext2_ljj/file.c
  *
  * Copyright (C) 1992, 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -13,7 +13,7 @@
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
  *
- *  ext2 fs regular file handling primitives
+ *  ext2_ljj fs regular file handling primitives
  *
  *  64-bit file support on 64-bit platforms by Jakub Jelinek
  * 	(jj@sunsite.ms.mff.cuni.cz)
@@ -25,12 +25,12 @@
 #include <linux/quotaops.h>
 #include <linux/iomap.h>
 #include <linux/uio.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 #include "acl.h"
 
 #ifdef CONFIG_FS_DAX
-static ssize_t ext2_dax_read_iter(struct kiocb *iocb, struct iov_iter *to)
+static ssize_t ext2_ljj_dax_read_iter(struct kiocb *iocb, struct iov_iter *to)
 {
 	struct inode *inode = iocb->ki_filp->f_mapping->host;
 	ssize_t ret;
@@ -39,14 +39,14 @@
 		return 0; /* skip atime */
 
 	inode_lock_shared(inode);
-	ret = dax_iomap_rw(iocb, to, &ext2_iomap_ops);
+	ret = dax_iomap_rw(iocb, to, &ext2_ljj_iomap_ops);
 	inode_unlock_shared(inode);
 
 	file_accessed(iocb->ki_filp);
 	return ret;
 }
 
-static ssize_t ext2_dax_write_iter(struct kiocb *iocb, struct iov_iter *from)
+static ssize_t ext2_ljj_dax_write_iter(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *file = iocb->ki_filp;
 	struct inode *inode = file->f_mapping->host;
@@ -63,7 +63,7 @@
 	if (ret)
 		goto out_unlock;
 
-	ret = dax_iomap_rw(iocb, from, &ext2_iomap_ops);
+	ret = dax_iomap_rw(iocb, from, &ext2_ljj_iomap_ops);
 	if (ret > 0 && iocb->ki_pos > i_size_read(inode)) {
 		i_size_write(inode, iocb->ki_pos);
 		mark_inode_dirty(inode);
@@ -77,18 +77,18 @@
 }
 
 /*
- * The lock ordering for ext2 DAX fault paths is:
+ * The lock ordering for ext2_ljj DAX fault paths is:
  *
  * mmap_lock (MM)
  *   sb_start_pagefault (vfs, freeze)
  *     address_space->invalidate_lock
  *       address_space->i_mmap_rwsem or page_lock (mutually exclusive in DAX)
- *         ext2_inode_info->truncate_mutex
+ *         ext2_ljj_inode_info->truncate_mutex
  *
  * The default page_lock and i_size verification done by non-DAX fault paths
- * is sufficient because ext2 doesn't support hole punching.
+ * is sufficient because ext2_ljj doesn't support hole punching.
  */
-static vm_fault_t ext2_dax_fault(struct vm_fault *vmf)
+static vm_fault_t ext2_ljj_dax_fault(struct vm_fault *vmf)
 {
 	struct inode *inode = file_inode(vmf->vma->vm_file);
 	vm_fault_t ret;
@@ -101,7 +101,7 @@
 	}
 	filemap_invalidate_lock_shared(inode->i_mapping);
 
-	ret = dax_iomap_fault(vmf, PE_SIZE_PTE, NULL, NULL, &ext2_iomap_ops);
+	ret = dax_iomap_fault(vmf, PE_SIZE_PTE, NULL, NULL, &ext2_ljj_iomap_ops);
 
 	filemap_invalidate_unlock_shared(inode->i_mapping);
 	if (write)
@@ -109,28 +109,28 @@
 	return ret;
 }
 
-static const struct vm_operations_struct ext2_dax_vm_ops = {
-	.fault		= ext2_dax_fault,
+static const struct vm_operations_struct ext2_ljj_dax_vm_ops = {
+	.fault		= ext2_ljj_dax_fault,
 	/*
-	 * .huge_fault is not supported for DAX because allocation in ext2
+	 * .huge_fault is not supported for DAX because allocation in ext2_ljj
 	 * cannot be reliably aligned to huge page sizes and so pmd faults
 	 * will always fail and fail back to regular faults.
 	 */
-	.page_mkwrite	= ext2_dax_fault,
-	.pfn_mkwrite	= ext2_dax_fault,
+	.page_mkwrite	= ext2_ljj_dax_fault,
+	.pfn_mkwrite	= ext2_ljj_dax_fault,
 };
 
-static int ext2_file_mmap(struct file *file, struct vm_area_struct *vma)
+static int ext2_ljj_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	if (!IS_DAX(file_inode(file)))
 		return generic_file_mmap(file, vma);
 
 	file_accessed(file);
-	vma->vm_ops = &ext2_dax_vm_ops;
+	vma->vm_ops = &ext2_ljj_dax_vm_ops;
 	return 0;
 }
 #else
-#define ext2_file_mmap	generic_file_mmap
+#define ext2_ljj_file_mmap	generic_file_mmap
 #endif
 
 /*
@@ -138,17 +138,17 @@
  * for a single struct file are closed. Note that different open() calls
  * for the same file yield different struct file structures.
  */
-static int ext2_release_file (struct inode * inode, struct file * filp)
+static int ext2_ljj_release_file (struct inode * inode, struct file * filp)
 {
 	if (filp->f_mode & FMODE_WRITE) {
 		mutex_lock(&EXT2_I(inode)->truncate_mutex);
-		ext2_discard_reservation(inode);
+		ext2_ljj_discard_reservation(inode);
 		mutex_unlock(&EXT2_I(inode)->truncate_mutex);
 	}
 	return 0;
 }
 
-int ext2_fsync(struct file *file, loff_t start, loff_t end, int datasync)
+int ext2_ljj_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 {
 	int ret;
 	struct super_block *sb = file->f_mapping->host->i_sb;
@@ -156,53 +156,53 @@
 	ret = generic_file_fsync(file, start, end, datasync);
 	if (ret == -EIO)
 		/* We don't really know where the IO error happened... */
-		ext2_error(sb, __func__,
+		ext2_ljj_error(sb, __func__,
 			   "detected IO error when writing metadata buffers");
 	return ret;
 }
 
-static ssize_t ext2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
+static ssize_t ext2_ljj_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
 {
 #ifdef CONFIG_FS_DAX
 	if (IS_DAX(iocb->ki_filp->f_mapping->host))
-		return ext2_dax_read_iter(iocb, to);
+		return ext2_ljj_dax_read_iter(iocb, to);
 #endif
 	return generic_file_read_iter(iocb, to);
 }
 
-static ssize_t ext2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
+static ssize_t ext2_ljj_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 {
 #ifdef CONFIG_FS_DAX
 	if (IS_DAX(iocb->ki_filp->f_mapping->host))
-		return ext2_dax_write_iter(iocb, from);
+		return ext2_ljj_dax_write_iter(iocb, from);
 #endif
 	return generic_file_write_iter(iocb, from);
 }
 
-const struct file_operations ext2_file_operations = {
+const struct file_operations ext2_ljj_file_operations = {
 	.llseek		= generic_file_llseek,
-	.read_iter	= ext2_file_read_iter,
-	.write_iter	= ext2_file_write_iter,
-	.unlocked_ioctl = ext2_ioctl,
+	.read_iter	= ext2_ljj_file_read_iter,
+	.write_iter	= ext2_ljj_file_write_iter,
+	.unlocked_ioctl = ext2_ljj_ioctl,
 #ifdef CONFIG_COMPAT
-	.compat_ioctl	= ext2_compat_ioctl,
+	.compat_ioctl	= ext2_ljj_compat_ioctl,
 #endif
-	.mmap		= ext2_file_mmap,
+	.mmap		= ext2_ljj_file_mmap,
 	.open		= dquot_file_open,
-	.release	= ext2_release_file,
-	.fsync		= ext2_fsync,
+	.release	= ext2_ljj_release_file,
+	.fsync		= ext2_ljj_fsync,
 	.get_unmapped_area = thp_get_unmapped_area,
 	.splice_read	= generic_file_splice_read,
 	.splice_write	= iter_file_splice_write,
 };
 
-const struct inode_operations ext2_file_inode_operations = {
-	.listxattr	= ext2_listxattr,
-	.getattr	= ext2_getattr,
-	.setattr	= ext2_setattr,
-	.get_acl	= ext2_get_acl,
-	.set_acl	= ext2_set_acl,
-	.fiemap		= ext2_fiemap,
-	.fileattr_get	= ext2_fileattr_get,
-	.fileattr_set	= ext2_fileattr_set,
+const struct inode_operations ext2_ljj_file_inode_operations = {
+	.listxattr	= ext2_ljj_listxattr,
+	.getattr	= ext2_ljj_getattr,
+	.setattr	= ext2_ljj_setattr,
+	.get_acl	= ext2_ljj_get_acl,
+	.set_acl	= ext2_ljj_set_acl,
+	.fiemap		= ext2_ljj_fiemap,
+	.fileattr_get	= ext2_ljj_fileattr_get,
+	.fileattr_set	= ext2_ljj_fileattr_set,
 };
diff -urN fs/ext2/ialloc.c fs/ext2_ljj/ialloc.c
--- fs/ext2/ialloc.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/ialloc.c	2024-11-04 11:48:27.265696908 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *  linux/fs/ext2/ialloc.c
+ *  linux/fs/ext2_ljj/ialloc.c
  *
  * Copyright (C) 1992, 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -18,7 +18,7 @@
 #include <linux/backing-dev.h>
 #include <linux/buffer_head.h>
 #include <linux/random.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 #include "acl.h"
 
@@ -46,16 +46,16 @@
 static struct buffer_head *
 read_inode_bitmap(struct super_block * sb, unsigned long block_group)
 {
-	struct ext2_group_desc *desc;
+	struct ext2_ljj_group_desc *desc;
 	struct buffer_head *bh = NULL;
 
-	desc = ext2_get_group_desc(sb, block_group, NULL);
+	desc = ext2_ljj_get_group_desc(sb, block_group, NULL);
 	if (!desc)
 		goto error_out;
 
 	bh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));
 	if (!bh)
-		ext2_error(sb, "read_inode_bitmap",
+		ext2_ljj_error(sb, "read_inode_bitmap",
 			    "Cannot read inode bitmap - "
 			    "block_group = %lu, inode_bitmap = %u",
 			    block_group, le32_to_cpu(desc->bg_inode_bitmap));
@@ -63,14 +63,14 @@
 	return bh;
 }
 
-static void ext2_release_inode(struct super_block *sb, int group, int dir)
+static void ext2_ljj_release_inode(struct super_block *sb, int group, int dir)
 {
-	struct ext2_group_desc * desc;
+	struct ext2_ljj_group_desc * desc;
 	struct buffer_head *bh;
 
-	desc = ext2_get_group_desc(sb, group, &bh);
+	desc = ext2_ljj_get_group_desc(sb, group, &bh);
 	if (!desc) {
-		ext2_error(sb, "ext2_release_inode",
+		ext2_ljj_error(sb, "ext2_ljj_release_inode",
 			"can't get descriptor for group %d", group);
 		return;
 	}
@@ -102,7 +102,7 @@
  * though), and then we'd have two inodes sharing the
  * same inode number and space on the harddisk.
  */
-void ext2_free_inode (struct inode * inode)
+void ext2_ljj_free_inode (struct inode * inode)
 {
 	struct super_block * sb = inode->i_sb;
 	int is_directory;
@@ -110,10 +110,10 @@
 	struct buffer_head *bitmap_bh;
 	unsigned long block_group;
 	unsigned long bit;
-	struct ext2_super_block * es;
+	struct ext2_ljj_super_block * es;
 
 	ino = inode->i_ino;
-	ext2_debug ("freeing inode %lu\n", ino);
+	ext2_ljj_debug ("freeing inode %lu\n", ino);
 
 	/*
 	 * Note: we must free any quota before locking the superblock,
@@ -128,7 +128,7 @@
 
 	if (ino < EXT2_FIRST_INO(sb) ||
 	    ino > le32_to_cpu(es->s_inodes_count)) {
-		ext2_error (sb, "ext2_free_inode",
+		ext2_ljj_error (sb, "ext2_ljj_free_inode",
 			    "reserved or nonexistent inode %lu", ino);
 		return;
 	}
@@ -139,12 +139,12 @@
 		return;
 
 	/* Ok, now we can actually update the inode bitmaps.. */
-	if (!ext2_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),
+	if (!ext2_ljj_clear_bit_atomic(sb_bgl_lock(EXT2_SB(sb), block_group),
 				bit, (void *) bitmap_bh->b_data))
-		ext2_error (sb, "ext2_free_inode",
+		ext2_ljj_error (sb, "ext2_ljj_free_inode",
 			      "bit already cleared for inode %lu", ino);
 	else
-		ext2_release_inode(sb, block_group, is_directory);
+		ext2_ljj_release_inode(sb, block_group, is_directory);
 	mark_buffer_dirty(bitmap_bh);
 	if (sb->s_flags & SB_SYNCHRONOUS)
 		sync_dirty_buffer(bitmap_bh);
@@ -162,17 +162,17 @@
  * - When writing out a large number of inodes, we don't need to keep on
  *   stalling the writes while we read the inode block.
  *
- * FIXME: ext2_get_group_desc() needs to be simplified.
+ * FIXME: ext2_ljj_get_group_desc() needs to be simplified.
  */
-static void ext2_preread_inode(struct inode *inode)
+static void ext2_ljj_preread_inode(struct inode *inode)
 {
 	unsigned long block_group;
 	unsigned long offset;
 	unsigned long block;
-	struct ext2_group_desc * gdp;
+	struct ext2_ljj_group_desc * gdp;
 
 	block_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);
-	gdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);
+	gdp = ext2_ljj_get_group_desc(inode->i_sb, block_group, NULL);
 	if (gdp == NULL)
 		return;
 
@@ -199,12 +199,12 @@
 static int find_group_dir(struct super_block *sb, struct inode *parent)
 {
 	int ngroups = EXT2_SB(sb)->s_groups_count;
-	int avefreei = ext2_count_free_inodes(sb) / ngroups;
-	struct ext2_group_desc *desc, *best_desc = NULL;
+	int avefreei = ext2_ljj_count_free_inodes(sb) / ngroups;
+	struct ext2_ljj_group_desc *desc, *best_desc = NULL;
 	int group, best_group = -1;
 
 	for (group = 0; group < ngroups; group++) {
-		desc = ext2_get_group_desc (sb, group, NULL);
+		desc = ext2_ljj_get_group_desc (sb, group, NULL);
 		if (!desc || !desc->bg_free_inodes_count)
 			continue;
 		if (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)
@@ -251,8 +251,8 @@
 static int find_group_orlov(struct super_block *sb, struct inode *parent)
 {
 	int parent_group = EXT2_I(parent)->i_block_group;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
-	struct ext2_super_block *es = sbi->s_es;
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_super_block *es = sbi->s_es;
 	int ngroups = sbi->s_groups_count;
 	int inodes_per_group = EXT2_INODES_PER_GROUP(sb);
 	int freei;
@@ -263,7 +263,7 @@
 	int ndirs;
 	int max_debt, max_dirs, min_blocks, min_inodes;
 	int group = -1, i;
-	struct ext2_group_desc *desc;
+	struct ext2_ljj_group_desc *desc;
 
 	freei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);
 	avefreei = freei / ngroups;
@@ -273,14 +273,14 @@
 
 	if ((parent == d_inode(sb->s_root)) ||
 	    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {
-		struct ext2_group_desc *best_desc = NULL;
+		struct ext2_ljj_group_desc *best_desc = NULL;
 		int best_ndir = inodes_per_group;
 		int best_group = -1;
 
 		parent_group = prandom_u32_max(ngroups);
 		for (i = 0; i < ngroups; i++) {
 			group = (parent_group + i) % ngroups;
-			desc = ext2_get_group_desc (sb, group, NULL);
+			desc = ext2_ljj_get_group_desc (sb, group, NULL);
 			if (!desc || !desc->bg_free_inodes_count)
 				continue;
 			if (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)
@@ -320,7 +320,7 @@
 
 	for (i = 0; i < ngroups; i++) {
 		group = (parent_group + i) % ngroups;
-		desc = ext2_get_group_desc (sb, group, NULL);
+		desc = ext2_ljj_get_group_desc (sb, group, NULL);
 		if (!desc || !desc->bg_free_inodes_count)
 			continue;
 		if (sbi->s_debts[group] >= max_debt)
@@ -337,7 +337,7 @@
 fallback:
 	for (i = 0; i < ngroups; i++) {
 		group = (parent_group + i) % ngroups;
-		desc = ext2_get_group_desc (sb, group, NULL);
+		desc = ext2_ljj_get_group_desc (sb, group, NULL);
 		if (!desc || !desc->bg_free_inodes_count)
 			continue;
 		if (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)
@@ -363,14 +363,14 @@
 {
 	int parent_group = EXT2_I(parent)->i_block_group;
 	int ngroups = EXT2_SB(sb)->s_groups_count;
-	struct ext2_group_desc *desc;
+	struct ext2_ljj_group_desc *desc;
 	int group, i;
 
 	/*
 	 * Try to place the inode in its parent directory
 	 */
 	group = parent_group;
-	desc = ext2_get_group_desc (sb, group, NULL);
+	desc = ext2_ljj_get_group_desc (sb, group, NULL);
 	if (desc && le16_to_cpu(desc->bg_free_inodes_count) &&
 			le16_to_cpu(desc->bg_free_blocks_count))
 		goto found;
@@ -394,7 +394,7 @@
 		group += i;
 		if (group >= ngroups)
 			group -= ngroups;
-		desc = ext2_get_group_desc (sb, group, NULL);
+		desc = ext2_ljj_get_group_desc (sb, group, NULL);
 		if (desc && le16_to_cpu(desc->bg_free_inodes_count) &&
 				le16_to_cpu(desc->bg_free_blocks_count))
 			goto found;
@@ -408,7 +408,7 @@
 	for (i = 0; i < ngroups; i++) {
 		if (++group >= ngroups)
 			group = 0;
-		desc = ext2_get_group_desc (sb, group, NULL);
+		desc = ext2_ljj_get_group_desc (sb, group, NULL);
 		if (desc && le16_to_cpu(desc->bg_free_inodes_count))
 			goto found;
 	}
@@ -419,7 +419,7 @@
 	return group;
 }
 
-struct inode *ext2_new_inode(struct inode *dir, umode_t mode,
+struct inode *ext2_ljj_new_inode(struct inode *dir, umode_t mode,
 			     const struct qstr *qstr)
 {
 	struct super_block *sb;
@@ -428,10 +428,10 @@
 	int group, i;
 	ino_t ino = 0;
 	struct inode * inode;
-	struct ext2_group_desc *gdp;
-	struct ext2_super_block *es;
-	struct ext2_inode_info *ei;
-	struct ext2_sb_info *sbi;
+	struct ext2_ljj_group_desc *gdp;
+	struct ext2_ljj_super_block *es;
+	struct ext2_ljj_inode_info *ei;
+	struct ext2_ljj_sb_info *sbi;
 	int err;
 
 	sb = dir->i_sb;
@@ -456,7 +456,7 @@
 	}
 
 	for (i = 0; i < sbi->s_groups_count; i++) {
-		gdp = ext2_get_group_desc(sb, group, &bh2);
+		gdp = ext2_ljj_get_group_desc(sb, group, &bh2);
 		if (!gdp) {
 			if (++group == sbi->s_groups_count)
 				group = 0;
@@ -471,7 +471,7 @@
 		ino = 0;
 
 repeat_in_this_group:
-		ino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,
+		ino = ext2_ljj_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,
 					      EXT2_INODES_PER_GROUP(sb), ino);
 		if (ino >= EXT2_INODES_PER_GROUP(sb)) {
 			/*
@@ -486,7 +486,7 @@
 				group = 0;
 			continue;
 		}
-		if (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),
+		if (ext2_ljj_set_bit_atomic(sb_bgl_lock(sbi, group),
 						ino, bitmap_bh->b_data)) {
 			/* we lost this inode */
 			if (++ino >= EXT2_INODES_PER_GROUP(sb)) {
@@ -515,7 +515,7 @@
 
 	ino += group * EXT2_INODES_PER_GROUP(sb) + 1;
 	if (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {
-		ext2_error (sb, "ext2_new_inode",
+		ext2_ljj_error (sb, "ext2_ljj_new_inode",
 			    "reserved inode or inode > inodes count - "
 			    "block_group = %d,inode=%lu", group,
 			    (unsigned long) ino);
@@ -552,7 +552,7 @@
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 	memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_flags =
-		ext2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);
+		ext2_ljj_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);
 	ei->i_faddr = 0;
 	ei->i_frag_no = 0;
 	ei->i_frag_size = 0;
@@ -563,12 +563,12 @@
 	ei->i_block_group = group;
 	ei->i_dir_start_lookup = 0;
 	ei->i_state = EXT2_STATE_NEW;
-	ext2_set_inode_flags(inode);
+	ext2_ljj_set_inode_flags(inode);
 	spin_lock(&sbi->s_next_gen_lock);
 	inode->i_generation = sbi->s_next_generation++;
 	spin_unlock(&sbi->s_next_gen_lock);
 	if (insert_inode_locked(inode) < 0) {
-		ext2_error(sb, "ext2_new_inode",
+		ext2_ljj_error(sb, "ext2_ljj_new_inode",
 			   "inode number already in use - inode=%lu",
 			   (unsigned long) ino);
 		err = -EIO;
@@ -583,17 +583,17 @@
 	if (err)
 		goto fail_drop;
 
-	err = ext2_init_acl(inode, dir);
+	err = ext2_ljj_init_acl(inode, dir);
 	if (err)
 		goto fail_free_drop;
 
-	err = ext2_init_security(inode, dir, qstr);
+	err = ext2_ljj_init_security(inode, dir, qstr);
 	if (err)
 		goto fail_free_drop;
 
 	mark_inode_dirty(inode);
-	ext2_debug("allocating inode %lu\n", inode->i_ino);
-	ext2_preread_inode(inode);
+	ext2_ljj_debug("allocating inode %lu\n", inode->i_ino);
+	ext2_ljj_preread_inode(inode);
 	return inode;
 
 fail_free_drop:
@@ -612,14 +612,14 @@
 	return ERR_PTR(err);
 }
 
-unsigned long ext2_count_free_inodes (struct super_block * sb)
+unsigned long ext2_ljj_count_free_inodes (struct super_block * sb)
 {
-	struct ext2_group_desc *desc;
+	struct ext2_ljj_group_desc *desc;
 	unsigned long desc_count = 0;
 	int i;	
 
 #ifdef EXT2FS_DEBUG
-	struct ext2_super_block *es;
+	struct ext2_ljj_super_block *es;
 	unsigned long bitmap_count = 0;
 	struct buffer_head *bitmap_bh = NULL;
 
@@ -627,7 +627,7 @@
 	for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {
 		unsigned x;
 
-		desc = ext2_get_group_desc (sb, i, NULL);
+		desc = ext2_ljj_get_group_desc (sb, i, NULL);
 		if (!desc)
 			continue;
 		desc_count += le16_to_cpu(desc->bg_free_inodes_count);
@@ -636,20 +636,20 @@
 		if (!bitmap_bh)
 			continue;
 
-		x = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);
+		x = ext2_ljj_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);
 		printk("group %d: stored = %d, counted = %u\n",
 			i, le16_to_cpu(desc->bg_free_inodes_count), x);
 		bitmap_count += x;
 	}
 	brelse(bitmap_bh);
-	printk("ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\n",
+	printk("ext2_ljj_count_free_inodes: stored = %lu, computed = %lu, %lu\n",
 		(unsigned long)
 		percpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),
 		desc_count, bitmap_count);
 	return desc_count;
 #else
 	for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {
-		desc = ext2_get_group_desc (sb, i, NULL);
+		desc = ext2_ljj_get_group_desc (sb, i, NULL);
 		if (!desc)
 			continue;
 		desc_count += le16_to_cpu(desc->bg_free_inodes_count);
@@ -659,13 +659,13 @@
 }
 
 /* Called at mount-time, super-block is locked */
-unsigned long ext2_count_dirs (struct super_block * sb)
+unsigned long ext2_ljj_count_dirs (struct super_block * sb)
 {
 	unsigned long count = 0;
 	int i;
 
 	for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {
-		struct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);
+		struct ext2_ljj_group_desc *gdp = ext2_ljj_get_group_desc (sb, i, NULL);
 		if (!gdp)
 			continue;
 		count += le16_to_cpu(gdp->bg_used_dirs_count);
diff -urN fs/ext2/inode.c fs/ext2_ljj/inode.c
--- fs/ext2/inode.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/inode.c	2024-11-04 11:48:27.269696626 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *  linux/fs/ext2/inode.c
+ *  linux/fs/ext2_ljj/inode.c
  *
  * Copyright (C) 1992, 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -20,7 +20,7 @@
  *  64-bit file support on 64-bit platforms by Jakub Jelinek
  * 	(jj@sunsite.ms.mff.cuni.cz)
  *
- *  Assorted race fixes, rewrite of ext2_get_block() by Al Viro, 2000
+ *  Assorted race fixes, rewrite of ext2_ljj_get_block() by Al Viro, 2000
  */
 
 #include <linux/time.h>
@@ -36,16 +36,16 @@
 #include <linux/iomap.h>
 #include <linux/namei.h>
 #include <linux/uio.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "acl.h"
 #include "xattr.h"
 
-static int __ext2_write_inode(struct inode *inode, int do_sync);
+static int __ext2_ljj_write_inode(struct inode *inode, int do_sync);
 
 /*
  * Test whether an inode is a fast symlink.
  */
-static inline int ext2_inode_is_fast_symlink(struct inode *inode)
+static inline int ext2_ljj_inode_is_fast_symlink(struct inode *inode)
 {
 	int ea_blocks = EXT2_I(inode)->i_file_acl ?
 		(inode->i_sb->s_blocksize >> 9) : 0;
@@ -54,24 +54,24 @@
 		inode->i_blocks - ea_blocks == 0);
 }
 
-static void ext2_truncate_blocks(struct inode *inode, loff_t offset);
+static void ext2_ljj_truncate_blocks(struct inode *inode, loff_t offset);
 
-static void ext2_write_failed(struct address_space *mapping, loff_t to)
+static void ext2_ljj_write_failed(struct address_space *mapping, loff_t to)
 {
 	struct inode *inode = mapping->host;
 
 	if (to > inode->i_size) {
 		truncate_pagecache(inode, inode->i_size);
-		ext2_truncate_blocks(inode, inode->i_size);
+		ext2_ljj_truncate_blocks(inode, inode->i_size);
 	}
 }
 
 /*
  * Called at the last iput() if i_nlink is zero.
  */
-void ext2_evict_inode(struct inode * inode)
+void ext2_ljj_evict_inode(struct inode * inode)
 {
-	struct ext2_block_alloc_info *rsv;
+	struct ext2_ljj_block_alloc_info *rsv;
 	int want_delete = 0;
 
 	if (!inode->i_nlink && !is_bad_inode(inode)) {
@@ -88,25 +88,25 @@
 		/* set dtime */
 		EXT2_I(inode)->i_dtime	= ktime_get_real_seconds();
 		mark_inode_dirty(inode);
-		__ext2_write_inode(inode, inode_needs_sync(inode));
+		__ext2_ljj_write_inode(inode, inode_needs_sync(inode));
 		/* truncate to 0 */
 		inode->i_size = 0;
 		if (inode->i_blocks)
-			ext2_truncate_blocks(inode, 0);
-		ext2_xattr_delete_inode(inode);
+			ext2_ljj_truncate_blocks(inode, 0);
+		ext2_ljj_xattr_delete_inode(inode);
 	}
 
 	invalidate_inode_buffers(inode);
 	clear_inode(inode);
 
-	ext2_discard_reservation(inode);
+	ext2_ljj_discard_reservation(inode);
 	rsv = EXT2_I(inode)->i_block_alloc_info;
 	EXT2_I(inode)->i_block_alloc_info = NULL;
 	if (unlikely(rsv))
 		kfree(rsv);
 
 	if (want_delete) {
-		ext2_free_inode(inode);
+		ext2_ljj_free_inode(inode);
 		sb_end_intwrite(inode->i_sb);
 	}
 }
@@ -131,13 +131,13 @@
 }
 
 /**
- *	ext2_block_to_path - parse the block number into array of offsets
+ *	ext2_ljj_block_to_path - parse the block number into array of offsets
  *	@inode: inode in question (we are only interested in its superblock)
  *	@i_block: block number to be parsed
  *	@offsets: array to store the offsets in
  *      @boundary: set this non-zero if the referred-to block is likely to be
  *             followed (on disk) by an indirect block.
- *	To store the locations of file's data ext2 uses a data structure common
+ *	To store the locations of file's data ext2_ljj uses a data structure common
  *	for UNIX filesystems - tree of pointers anchored in the inode, with
  *	data blocks at leaves and indirect blocks in intermediate nodes.
  *	This function translates the block number into path in that tree -
@@ -160,7 +160,7 @@
  * get there at all.
  */
 
-static int ext2_block_to_path(struct inode *inode,
+static int ext2_ljj_block_to_path(struct inode *inode,
 			long i_block, int offsets[4], int *boundary)
 {
 	int ptrs = EXT2_ADDR_PER_BLOCK(inode->i_sb);
@@ -172,7 +172,7 @@
 	int final = 0;
 
 	if (i_block < 0) {
-		ext2_msg(inode->i_sb, KERN_WARNING,
+		ext2_ljj_msg(inode->i_sb, KERN_WARNING,
 			"warning: %s: block < 0", __func__);
 	} else if (i_block < direct_blocks) {
 		offsets[n++] = i_block;
@@ -193,7 +193,7 @@
 		offsets[n++] = i_block & (ptrs - 1);
 		final = ptrs;
 	} else {
-		ext2_msg(inode->i_sb, KERN_WARNING,
+		ext2_ljj_msg(inode->i_sb, KERN_WARNING,
 			"warning: %s: block is too big", __func__);
 	}
 	if (boundary)
@@ -203,7 +203,7 @@
 }
 
 /**
- *	ext2_get_branch - read the chain of indirect blocks leading to data
+ *	ext2_ljj_get_branch - read the chain of indirect blocks leading to data
  *	@inode: inode in question
  *	@depth: depth of the chain (1 - direct pointer, etc.)
  *	@offsets: offsets of pointers in inode/indirect blocks
@@ -231,7 +231,7 @@
  *	or when it reads all @depth-1 indirect blocks successfully and finds
  *	the whole chain, all way to the data (returns %NULL, *err == 0).
  */
-static Indirect *ext2_get_branch(struct inode *inode,
+static Indirect *ext2_ljj_get_branch(struct inode *inode,
 				 int depth,
 				 int *offsets,
 				 Indirect chain[4],
@@ -272,7 +272,7 @@
 }
 
 /**
- *	ext2_find_near - find a place for allocation with sufficient locality
+ *	ext2_ljj_find_near - find a place for allocation with sufficient locality
  *	@inode: owner
  *	@ind: descriptor of indirect block.
  *
@@ -291,13 +291,13 @@
  *	Caller must make sure that @ind is valid and will stay that way.
  */
 
-static ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)
+static ext2_ljj_fsblk_t ext2_ljj_find_near(struct inode *inode, Indirect *ind)
 {
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 	__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;
 	__le32 *p;
-	ext2_fsblk_t bg_start;
-	ext2_fsblk_t colour;
+	ext2_ljj_fsblk_t bg_start;
+	ext2_ljj_fsblk_t colour;
 
 	/* Try to find previous block */
 	for (p = ind->p - 1; p >= start; p--)
@@ -312,14 +312,14 @@
 	 * It is going to be referred from inode itself? OK, just put it into
 	 * the same cylinder group then.
 	 */
-	bg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);
+	bg_start = ext2_ljj_group_first_block_no(inode->i_sb, ei->i_block_group);
 	colour = (current->pid % 16) *
 			(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);
 	return bg_start + colour;
 }
 
 /**
- *	ext2_find_goal - find a preferred place for allocation.
+ *	ext2_ljj_find_goal - find a preferred place for allocation.
  *	@inode: owner
  *	@block:  block we want
  *	@partial: pointer to the last triple within a chain
@@ -327,10 +327,10 @@
  *	Returns preferred place for a block (the goal).
  */
 
-static inline ext2_fsblk_t ext2_find_goal(struct inode *inode, long block,
+static inline ext2_ljj_fsblk_t ext2_ljj_find_goal(struct inode *inode, long block,
 					  Indirect *partial)
 {
-	struct ext2_block_alloc_info *block_i;
+	struct ext2_ljj_block_alloc_info *block_i;
 
 	block_i = EXT2_I(inode)->i_block_alloc_info;
 
@@ -343,11 +343,11 @@
 		return block_i->last_alloc_physical_block + 1;
 	}
 
-	return ext2_find_near(inode, partial);
+	return ext2_ljj_find_near(inode, partial);
 }
 
 /**
- *	ext2_blks_to_allocate: Look up the block map and count the number
+ *	ext2_ljj_blks_to_allocate: Look up the block map and count the number
  *	of direct blocks need to be allocated for the given branch.
  *
  * 	@branch: chain of indirect blocks
@@ -358,7 +358,7 @@
  *	return the number of direct blocks to allocate.
  */
 static int
-ext2_blks_to_allocate(Indirect * branch, int k, unsigned long blks,
+ext2_ljj_blks_to_allocate(Indirect * branch, int k, unsigned long blks,
 		int blocks_to_boundary)
 {
 	unsigned long count = 0;
@@ -385,21 +385,21 @@
 }
 
 /**
- *	ext2_alloc_blocks: multiple allocate blocks needed for a branch
+ *	ext2_ljj_alloc_blocks: multiple allocate blocks needed for a branch
  *	@indirect_blks: the number of blocks need to allocate for indirect
  *			blocks
  *	@blks: the number of blocks need to allocate for direct blocks
  *	@new_blocks: on return it will store the new block numbers for
  *	the indirect blocks(if needed) and the first direct block,
  */
-static int ext2_alloc_blocks(struct inode *inode,
-			ext2_fsblk_t goal, int indirect_blks, int blks,
-			ext2_fsblk_t new_blocks[4], int *err)
+static int ext2_ljj_alloc_blocks(struct inode *inode,
+			ext2_ljj_fsblk_t goal, int indirect_blks, int blks,
+			ext2_ljj_fsblk_t new_blocks[4], int *err)
 {
 	int target, i;
 	unsigned long count = 0;
 	int index = 0;
-	ext2_fsblk_t current_block = 0;
+	ext2_ljj_fsblk_t current_block = 0;
 	int ret = 0;
 
 	/*
@@ -415,7 +415,7 @@
 	while (1) {
 		count = target;
 		/* allocating blocks for indirect blocks and direct blocks */
-		current_block = ext2_new_blocks(inode,goal,&count,err);
+		current_block = ext2_ljj_new_blocks(inode,goal,&count,err);
 		if (*err)
 			goto failed_out;
 
@@ -439,14 +439,14 @@
 	return ret;
 failed_out:
 	for (i = 0; i <index; i++)
-		ext2_free_blocks(inode, new_blocks[i], 1);
+		ext2_ljj_free_blocks(inode, new_blocks[i], 1);
 	if (index)
 		mark_inode_dirty(inode);
 	return ret;
 }
 
 /**
- *	ext2_alloc_branch - allocate and set up a chain of blocks.
+ *	ext2_ljj_alloc_branch - allocate and set up a chain of blocks.
  *	@inode: owner
  *	@indirect_blks: depth of the chain (number of blocks to allocate)
  *	@blks: number of allocated direct blocks
@@ -458,22 +458,22 @@
  *	links them into chain and (if we are synchronous) writes them to disk.
  *	In other words, it prepares a branch that can be spliced onto the
  *	inode. It stores the information about that chain in the branch[], in
- *	the same format as ext2_get_branch() would do. We are calling it after
+ *	the same format as ext2_ljj_get_branch() would do. We are calling it after
  *	we had read the existing part of chain and partial points to the last
  *	triple of that (one with zero ->key). Upon the exit we have the same
- *	picture as after the successful ext2_get_block(), except that in one
+ *	picture as after the successful ext2_ljj_get_block(), except that in one
  *	place chain is disconnected - *branch->p is still zero (we did not
  *	set the last link), but branch->key contains the number that should
  *	be placed into *branch->p to fill that gap.
  *
  *	If allocation fails we free all blocks we've allocated (and forget
  *	their buffer_heads) and return the error value the from failed
- *	ext2_alloc_block() (normally -ENOSPC). Otherwise we set the chain
+ *	ext2_ljj_alloc_block() (normally -ENOSPC). Otherwise we set the chain
  *	as described above and return 0.
  */
 
-static int ext2_alloc_branch(struct inode *inode,
-			int indirect_blks, int *blks, ext2_fsblk_t goal,
+static int ext2_ljj_alloc_branch(struct inode *inode,
+			int indirect_blks, int *blks, ext2_ljj_fsblk_t goal,
 			int *offsets, Indirect *branch)
 {
 	int blocksize = inode->i_sb->s_blocksize;
@@ -481,10 +481,10 @@
 	int err = 0;
 	struct buffer_head *bh;
 	int num;
-	ext2_fsblk_t new_blocks[4];
-	ext2_fsblk_t current_block;
+	ext2_ljj_fsblk_t new_blocks[4];
+	ext2_ljj_fsblk_t current_block;
 
-	num = ext2_alloc_blocks(inode, goal, indirect_blks,
+	num = ext2_ljj_alloc_blocks(inode, goal, indirect_blks,
 				*blks, new_blocks, &err);
 	if (err)
 		return err;
@@ -537,13 +537,13 @@
 	for (i = 1; i < n; i++)
 		bforget(branch[i].bh);
 	for (i = 0; i < indirect_blks; i++)
-		ext2_free_blocks(inode, new_blocks[i], 1);
-	ext2_free_blocks(inode, new_blocks[i], num);
+		ext2_ljj_free_blocks(inode, new_blocks[i], 1);
+	ext2_ljj_free_blocks(inode, new_blocks[i], num);
 	return err;
 }
 
 /**
- * ext2_splice_branch - splice the allocated branch onto inode.
+ * ext2_ljj_splice_branch - splice the allocated branch onto inode.
  * @inode: owner
  * @block: (logical) number of block we are adding
  * @where: location of missing link
@@ -554,12 +554,12 @@
  * inode (->i_blocks, etc.). In case of success we end up with the full
  * chain to new block and return 0.
  */
-static void ext2_splice_branch(struct inode *inode,
+static void ext2_ljj_splice_branch(struct inode *inode,
 			long block, Indirect *where, int num, int blks)
 {
 	int i;
-	struct ext2_block_alloc_info *block_i;
-	ext2_fsblk_t current_block;
+	struct ext2_ljj_block_alloc_info *block_i;
+	ext2_ljj_fsblk_t current_block;
 
 	block_i = EXT2_I(inode)->i_block_alloc_info;
 
@@ -617,7 +617,7 @@
  * return = 0, if plain lookup failed.
  * return < 0, error case.
  */
-static int ext2_get_blocks(struct inode *inode,
+static int ext2_ljj_get_blocks(struct inode *inode,
 			   sector_t iblock, unsigned long maxblocks,
 			   u32 *bno, bool *new, bool *boundary,
 			   int create)
@@ -626,29 +626,29 @@
 	int offsets[4];
 	Indirect chain[4];
 	Indirect *partial;
-	ext2_fsblk_t goal;
+	ext2_ljj_fsblk_t goal;
 	int indirect_blks;
 	int blocks_to_boundary = 0;
 	int depth;
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 	int count = 0;
-	ext2_fsblk_t first_block = 0;
+	ext2_ljj_fsblk_t first_block = 0;
 
 	BUG_ON(maxblocks == 0);
 
-	depth = ext2_block_to_path(inode,iblock,offsets,&blocks_to_boundary);
+	depth = ext2_ljj_block_to_path(inode,iblock,offsets,&blocks_to_boundary);
 
 	if (depth == 0)
 		return -EIO;
 
-	partial = ext2_get_branch(inode, depth, offsets, chain, &err);
+	partial = ext2_ljj_get_branch(inode, depth, offsets, chain, &err);
 	/* Simplest case - block found, no allocation needed */
 	if (!partial) {
 		first_block = le32_to_cpu(chain[depth - 1].key);
 		count++;
 		/*map more blocks*/
 		while (count < maxblocks && count <= blocks_to_boundary) {
-			ext2_fsblk_t blk;
+			ext2_ljj_fsblk_t blk;
 
 			if (!verify_chain(chain, chain + depth - 1)) {
 				/*
@@ -679,7 +679,7 @@
 	mutex_lock(&ei->truncate_mutex);
 	/*
 	 * If the indirect block is missing while we are reading
-	 * the chain(ext2_get_branch() returns -EAGAIN err), or
+	 * the chain(ext2_ljj_get_branch() returns -EAGAIN err), or
 	 * if the chain has been changed after we grab the semaphore,
 	 * (either because another process truncated this branch, or
 	 * another get_block allocated this branch) re-grab the chain to see if
@@ -694,7 +694,7 @@
 			brelse(partial->bh);
 			partial--;
 		}
-		partial = ext2_get_branch(inode, depth, offsets, chain, &err);
+		partial = ext2_ljj_get_branch(inode, depth, offsets, chain, &err);
 		if (!partial) {
 			count++;
 			mutex_unlock(&ei->truncate_mutex);
@@ -712,9 +712,9 @@
 	 * allocation info here if necessary
 	*/
 	if (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))
-		ext2_init_block_alloc_info(inode);
+		ext2_ljj_init_block_alloc_info(inode);
 
-	goal = ext2_find_goal(inode, iblock, partial);
+	goal = ext2_ljj_find_goal(inode, iblock, partial);
 
 	/* the number of blocks need to allocate for [d,t]indirect blocks */
 	indirect_blks = (chain + depth) - partial - 1;
@@ -722,12 +722,12 @@
 	 * Next look up the indirect map to count the total number of
 	 * direct blocks to allocate for this branch.
 	 */
-	count = ext2_blks_to_allocate(partial, indirect_blks,
+	count = ext2_ljj_blks_to_allocate(partial, indirect_blks,
 					maxblocks, blocks_to_boundary);
 	/*
-	 * XXX ???? Block out ext2_truncate while we alter the tree
+	 * XXX ???? Block out ext2_ljj_truncate while we alter the tree
 	 */
-	err = ext2_alloc_branch(inode, indirect_blks, &count, goal,
+	err = ext2_ljj_alloc_branch(inode, indirect_blks, &count, goal,
 				offsets + (partial - chain), partial);
 
 	if (err) {
@@ -758,7 +758,7 @@
 	}
 	*new = true;
 
-	ext2_splice_branch(inode, iblock, partial, indirect_blks, count);
+	ext2_ljj_splice_branch(inode, iblock, partial, indirect_blks, count);
 	mutex_unlock(&ei->truncate_mutex);
 got_it:
 	if (count > blocks_to_boundary)
@@ -776,7 +776,7 @@
 	return err;
 }
 
-int ext2_get_block(struct inode *inode, sector_t iblock,
+int ext2_ljj_get_block(struct inode *inode, sector_t iblock,
 		struct buffer_head *bh_result, int create)
 {
 	unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;
@@ -784,7 +784,7 @@
 	u32 bno;
 	int ret;
 
-	ret = ext2_get_blocks(inode, iblock, max_blocks, &bno, &new, &boundary,
+	ret = ext2_ljj_get_blocks(inode, iblock, max_blocks, &bno, &new, &boundary,
 			create);
 	if (ret <= 0)
 		return ret;
@@ -799,18 +799,18 @@
 
 }
 
-static int ext2_iomap_begin(struct inode *inode, loff_t offset, loff_t length,
+static int ext2_ljj_iomap_begin(struct inode *inode, loff_t offset, loff_t length,
 		unsigned flags, struct iomap *iomap, struct iomap *srcmap)
 {
 	unsigned int blkbits = inode->i_blkbits;
 	unsigned long first_block = offset >> blkbits;
 	unsigned long max_blocks = (length + (1 << blkbits) - 1) >> blkbits;
-	struct ext2_sb_info *sbi = EXT2_SB(inode->i_sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(inode->i_sb);
 	bool new = false, boundary = false;
 	u32 bno;
 	int ret;
 
-	ret = ext2_get_blocks(inode, first_block, max_blocks,
+	ret = ext2_ljj_get_blocks(inode, first_block, max_blocks,
 			&bno, &new, &boundary, flags & IOMAP_WRITE);
 	if (ret < 0)
 		return ret;
@@ -841,62 +841,62 @@
 }
 
 static int
-ext2_iomap_end(struct inode *inode, loff_t offset, loff_t length,
+ext2_ljj_iomap_end(struct inode *inode, loff_t offset, loff_t length,
 		ssize_t written, unsigned flags, struct iomap *iomap)
 {
 	if (iomap->type == IOMAP_MAPPED &&
 	    written < length &&
 	    (flags & IOMAP_WRITE))
-		ext2_write_failed(inode->i_mapping, offset + length);
+		ext2_ljj_write_failed(inode->i_mapping, offset + length);
 	return 0;
 }
 
-const struct iomap_ops ext2_iomap_ops = {
-	.iomap_begin		= ext2_iomap_begin,
-	.iomap_end		= ext2_iomap_end,
+const struct iomap_ops ext2_ljj_iomap_ops = {
+	.iomap_begin		= ext2_ljj_iomap_begin,
+	.iomap_end		= ext2_ljj_iomap_end,
 };
 
-int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
+int ext2_ljj_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 		u64 start, u64 len)
 {
 	int ret;
 
 	inode_lock(inode);
 	len = min_t(u64, len, i_size_read(inode));
-	ret = iomap_fiemap(inode, fieinfo, start, len, &ext2_iomap_ops);
+	ret = iomap_fiemap(inode, fieinfo, start, len, &ext2_ljj_iomap_ops);
 	inode_unlock(inode);
 
 	return ret;
 }
 
-static int ext2_writepage(struct page *page, struct writeback_control *wbc)
+static int ext2_ljj_writepage(struct page *page, struct writeback_control *wbc)
 {
-	return block_write_full_page(page, ext2_get_block, wbc);
+	return block_write_full_page(page, ext2_ljj_get_block, wbc);
 }
 
-static int ext2_read_folio(struct file *file, struct folio *folio)
+static int ext2_ljj_read_folio(struct file *file, struct folio *folio)
 {
-	return mpage_read_folio(folio, ext2_get_block);
+	return mpage_read_folio(folio, ext2_ljj_get_block);
 }
 
-static void ext2_readahead(struct readahead_control *rac)
+static void ext2_ljj_readahead(struct readahead_control *rac)
 {
-	mpage_readahead(rac, ext2_get_block);
+	mpage_readahead(rac, ext2_ljj_get_block);
 }
 
 static int
-ext2_write_begin(struct file *file, struct address_space *mapping,
+ext2_ljj_write_begin(struct file *file, struct address_space *mapping,
 		loff_t pos, unsigned len, struct page **pagep, void **fsdata)
 {
 	int ret;
 
-	ret = block_write_begin(mapping, pos, len, pagep, ext2_get_block);
+	ret = block_write_begin(mapping, pos, len, pagep, ext2_ljj_get_block);
 	if (ret < 0)
-		ext2_write_failed(mapping, pos + len);
+		ext2_ljj_write_failed(mapping, pos + len);
 	return ret;
 }
 
-static int ext2_write_end(struct file *file, struct address_space *mapping,
+static int ext2_ljj_write_end(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned copied,
 			struct page *page, void *fsdata)
 {
@@ -904,17 +904,17 @@
 
 	ret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);
 	if (ret < len)
-		ext2_write_failed(mapping, pos + len);
+		ext2_ljj_write_failed(mapping, pos + len);
 	return ret;
 }
 
-static sector_t ext2_bmap(struct address_space *mapping, sector_t block)
+static sector_t ext2_ljj_bmap(struct address_space *mapping, sector_t block)
 {
-	return generic_block_bmap(mapping,block,ext2_get_block);
+	return generic_block_bmap(mapping,block,ext2_ljj_get_block);
 }
 
 static ssize_t
-ext2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
+ext2_ljj_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb->ki_filp;
 	struct address_space *mapping = file->f_mapping;
@@ -923,44 +923,44 @@
 	loff_t offset = iocb->ki_pos;
 	ssize_t ret;
 
-	ret = blockdev_direct_IO(iocb, inode, iter, ext2_get_block);
+	ret = blockdev_direct_IO(iocb, inode, iter, ext2_ljj_get_block);
 	if (ret < 0 && iov_iter_rw(iter) == WRITE)
-		ext2_write_failed(mapping, offset + count);
+		ext2_ljj_write_failed(mapping, offset + count);
 	return ret;
 }
 
 static int
-ext2_writepages(struct address_space *mapping, struct writeback_control *wbc)
+ext2_ljj_writepages(struct address_space *mapping, struct writeback_control *wbc)
 {
-	return mpage_writepages(mapping, wbc, ext2_get_block);
+	return mpage_writepages(mapping, wbc, ext2_ljj_get_block);
 }
 
 static int
-ext2_dax_writepages(struct address_space *mapping, struct writeback_control *wbc)
+ext2_ljj_dax_writepages(struct address_space *mapping, struct writeback_control *wbc)
 {
-	struct ext2_sb_info *sbi = EXT2_SB(mapping->host->i_sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(mapping->host->i_sb);
 
 	return dax_writeback_mapping_range(mapping, sbi->s_daxdev, wbc);
 }
 
-const struct address_space_operations ext2_aops = {
+const struct address_space_operations ext2_ljj_aops = {
 	.dirty_folio		= block_dirty_folio,
 	.invalidate_folio	= block_invalidate_folio,
-	.read_folio		= ext2_read_folio,
-	.readahead		= ext2_readahead,
-	.writepage		= ext2_writepage,
-	.write_begin		= ext2_write_begin,
-	.write_end		= ext2_write_end,
-	.bmap			= ext2_bmap,
-	.direct_IO		= ext2_direct_IO,
-	.writepages		= ext2_writepages,
+	.read_folio		= ext2_ljj_read_folio,
+	.readahead		= ext2_ljj_readahead,
+	.writepage		= ext2_ljj_writepage,
+	.write_begin		= ext2_ljj_write_begin,
+	.write_end		= ext2_ljj_write_end,
+	.bmap			= ext2_ljj_bmap,
+	.direct_IO		= ext2_ljj_direct_IO,
+	.writepages		= ext2_ljj_writepages,
 	.migrate_folio		= buffer_migrate_folio,
 	.is_partially_uptodate	= block_is_partially_uptodate,
 	.error_remove_page	= generic_error_remove_page,
 };
 
-static const struct address_space_operations ext2_dax_aops = {
-	.writepages		= ext2_dax_writepages,
+static const struct address_space_operations ext2_ljj_dax_aops = {
+	.writepages		= ext2_ljj_dax_writepages,
 	.direct_IO		= noop_direct_IO,
 	.dirty_folio		= noop_dirty_folio,
 };
@@ -979,14 +979,14 @@
 }
 
 /**
- *	ext2_find_shared - find the indirect blocks for partial truncation.
+ *	ext2_ljj_find_shared - find the indirect blocks for partial truncation.
  *	@inode:	  inode in question
  *	@depth:	  depth of the affected branch
- *	@offsets: offsets of pointers in that branch (see ext2_block_to_path)
+ *	@offsets: offsets of pointers in that branch (see ext2_ljj_block_to_path)
  *	@chain:	  place to store the pointers to partial indirect blocks
  *	@top:	  place to the (detached) top of branch
  *
- *	This is a helper function used by ext2_truncate().
+ *	This is a helper function used by ext2_ljj_truncate().
  *
  *	When we do truncate() we may have to clean the ends of several indirect
  *	blocks but leave the blocks themselves alive. Block is partially
@@ -994,7 +994,7 @@
  *	it is on the path to the first completely truncated data block, indeed).
  *	We have to free the top of that path along with everything to the right
  *	of the path. Since no allocation past the truncation point is possible
- *	until ext2_truncate() finishes, we may safely do the latter, but top
+ *	until ext2_ljj_truncate() finishes, we may safely do the latter, but top
  *	of branch may require special attention - pageout below the truncation
  *	point might try to populate it.
  *
@@ -1012,7 +1012,7 @@
  *			(no partially truncated stuff there).
  */
 
-static Indirect *ext2_find_shared(struct inode *inode,
+static Indirect *ext2_ljj_find_shared(struct inode *inode,
 				int depth,
 				int offsets[4],
 				Indirect chain[4],
@@ -1024,7 +1024,7 @@
 	*top = 0;
 	for (k = depth; k > 1 && !offsets[k-1]; k--)
 		;
-	partial = ext2_get_branch(inode, k, offsets, chain, &err);
+	partial = ext2_ljj_get_branch(inode, k, offsets, chain, &err);
 	if (!partial)
 		partial = chain + k-1;
 	/*
@@ -1062,7 +1062,7 @@
 }
 
 /**
- *	ext2_free_data - free a list of data blocks
+ *	ext2_ljj_free_data - free a list of data blocks
  *	@inode:	inode we are dealing with
  *	@p:	array of block numbers
  *	@q:	points immediately past the end of array
@@ -1071,7 +1071,7 @@
  *	stored as little-endian 32-bit) and updating @inode->i_blocks
  *	appropriately.
  */
-static inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)
+static inline void ext2_ljj_free_data(struct inode *inode, __le32 *p, __le32 *q)
 {
 	unsigned long block_to_free = 0, count = 0;
 	unsigned long nr;
@@ -1086,7 +1086,7 @@
 			else if (block_to_free == nr - count)
 				count++;
 			else {
-				ext2_free_blocks (inode, block_to_free, count);
+				ext2_ljj_free_blocks (inode, block_to_free, count);
 				mark_inode_dirty(inode);
 			free_this:
 				block_to_free = nr;
@@ -1095,13 +1095,13 @@
 		}
 	}
 	if (count > 0) {
-		ext2_free_blocks (inode, block_to_free, count);
+		ext2_ljj_free_blocks (inode, block_to_free, count);
 		mark_inode_dirty(inode);
 	}
 }
 
 /**
- *	ext2_free_branches - free an array of branches
+ *	ext2_ljj_free_branches - free an array of branches
  *	@inode:	inode we are dealing with
  *	@p:	array of block numbers
  *	@q:	pointer immediately past the end of array
@@ -1111,7 +1111,7 @@
  *	stored as little-endian 32-bit) and updating @inode->i_blocks
  *	appropriately.
  */
-static void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)
+static void ext2_ljj_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)
 {
 	struct buffer_head * bh;
 	unsigned long nr;
@@ -1129,28 +1129,28 @@
 			 * (should be rare).
 			 */ 
 			if (!bh) {
-				ext2_error(inode->i_sb, "ext2_free_branches",
+				ext2_ljj_error(inode->i_sb, "ext2_ljj_free_branches",
 					"Read failure, inode=%ld, block=%ld",
 					inode->i_ino, nr);
 				continue;
 			}
-			ext2_free_branches(inode,
+			ext2_ljj_free_branches(inode,
 					   (__le32*)bh->b_data,
 					   (__le32*)bh->b_data + addr_per_block,
 					   depth);
 			bforget(bh);
-			ext2_free_blocks(inode, nr, 1);
+			ext2_ljj_free_blocks(inode, nr, 1);
 			mark_inode_dirty(inode);
 		}
 	} else
-		ext2_free_data(inode, p, q);
+		ext2_ljj_free_data(inode, p, q);
 }
 
 /* mapping->invalidate_lock must be held when calling this function */
-static void __ext2_truncate_blocks(struct inode *inode, loff_t offset)
+static void __ext2_ljj_truncate_blocks(struct inode *inode, loff_t offset)
 {
 	__le32 *i_data = EXT2_I(inode)->i_data;
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 	int addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);
 	int offsets[4];
 	Indirect chain[4];
@@ -1166,34 +1166,34 @@
 	WARN_ON(!rwsem_is_locked(&inode->i_mapping->invalidate_lock));
 #endif
 
-	n = ext2_block_to_path(inode, iblock, offsets, NULL);
+	n = ext2_ljj_block_to_path(inode, iblock, offsets, NULL);
 	if (n == 0)
 		return;
 
 	/*
-	 * From here we block out all ext2_get_block() callers who want to
+	 * From here we block out all ext2_ljj_get_block() callers who want to
 	 * modify the block allocation tree.
 	 */
 	mutex_lock(&ei->truncate_mutex);
 
 	if (n == 1) {
-		ext2_free_data(inode, i_data+offsets[0],
+		ext2_ljj_free_data(inode, i_data+offsets[0],
 					i_data + EXT2_NDIR_BLOCKS);
 		goto do_indirects;
 	}
 
-	partial = ext2_find_shared(inode, n, offsets, chain, &nr);
+	partial = ext2_ljj_find_shared(inode, n, offsets, chain, &nr);
 	/* Kill the top of shared branch (already detached) */
 	if (nr) {
 		if (partial == chain)
 			mark_inode_dirty(inode);
 		else
 			mark_buffer_dirty_inode(partial->bh, inode);
-		ext2_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);
+		ext2_ljj_free_branches(inode, &nr, &nr+1, (chain+n-1) - partial);
 	}
 	/* Clear the ends of indirect blocks on the shared branch */
 	while (partial > chain) {
-		ext2_free_branches(inode,
+		ext2_ljj_free_branches(inode,
 				   partial->p + 1,
 				   (__le32*)partial->bh->b_data+addr_per_block,
 				   (chain+n-1) - partial);
@@ -1209,7 +1209,7 @@
 			if (nr) {
 				i_data[EXT2_IND_BLOCK] = 0;
 				mark_inode_dirty(inode);
-				ext2_free_branches(inode, &nr, &nr+1, 1);
+				ext2_ljj_free_branches(inode, &nr, &nr+1, 1);
 			}
 			fallthrough;
 		case EXT2_IND_BLOCK:
@@ -1217,7 +1217,7 @@
 			if (nr) {
 				i_data[EXT2_DIND_BLOCK] = 0;
 				mark_inode_dirty(inode);
-				ext2_free_branches(inode, &nr, &nr+1, 2);
+				ext2_ljj_free_branches(inode, &nr, &nr+1, 2);
 			}
 			fallthrough;
 		case EXT2_DIND_BLOCK:
@@ -1225,39 +1225,39 @@
 			if (nr) {
 				i_data[EXT2_TIND_BLOCK] = 0;
 				mark_inode_dirty(inode);
-				ext2_free_branches(inode, &nr, &nr+1, 3);
+				ext2_ljj_free_branches(inode, &nr, &nr+1, 3);
 			}
 			break;
 		case EXT2_TIND_BLOCK:
 			;
 	}
 
-	ext2_discard_reservation(inode);
+	ext2_ljj_discard_reservation(inode);
 
 	mutex_unlock(&ei->truncate_mutex);
 }
 
-static void ext2_truncate_blocks(struct inode *inode, loff_t offset)
+static void ext2_ljj_truncate_blocks(struct inode *inode, loff_t offset)
 {
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return;
-	if (ext2_inode_is_fast_symlink(inode))
+	if (ext2_ljj_inode_is_fast_symlink(inode))
 		return;
 
 	filemap_invalidate_lock(inode->i_mapping);
-	__ext2_truncate_blocks(inode, offset);
+	__ext2_ljj_truncate_blocks(inode, offset);
 	filemap_invalidate_unlock(inode->i_mapping);
 }
 
-static int ext2_setsize(struct inode *inode, loff_t newsize)
+static int ext2_ljj_setsize(struct inode *inode, loff_t newsize)
 {
 	int error;
 
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
 		return -EINVAL;
-	if (ext2_inode_is_fast_symlink(inode))
+	if (ext2_ljj_inode_is_fast_symlink(inode))
 		return -EINVAL;
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return -EPERM;
@@ -1266,16 +1266,16 @@
 
 	if (IS_DAX(inode))
 		error = dax_truncate_page(inode, newsize, NULL,
-					  &ext2_iomap_ops);
+					  &ext2_ljj_iomap_ops);
 	else
 		error = block_truncate_page(inode->i_mapping,
-				newsize, ext2_get_block);
+				newsize, ext2_ljj_get_block);
 	if (error)
 		return error;
 
 	filemap_invalidate_lock(inode->i_mapping);
 	truncate_setsize(inode, newsize);
-	__ext2_truncate_blocks(inode, newsize);
+	__ext2_ljj_truncate_blocks(inode, newsize);
 	filemap_invalidate_unlock(inode->i_mapping);
 
 	inode->i_mtime = inode->i_ctime = current_time(inode);
@@ -1289,14 +1289,14 @@
 	return 0;
 }
 
-static struct ext2_inode *ext2_get_inode(struct super_block *sb, ino_t ino,
+static struct ext2_ljj_inode *ext2_ljj_get_inode(struct super_block *sb, ino_t ino,
 					struct buffer_head **p)
 {
 	struct buffer_head * bh;
 	unsigned long block_group;
 	unsigned long block;
 	unsigned long offset;
-	struct ext2_group_desc * gdp;
+	struct ext2_ljj_group_desc * gdp;
 
 	*p = NULL;
 	if ((ino != EXT2_ROOT_INO && ino < EXT2_FIRST_INO(sb)) ||
@@ -1304,7 +1304,7 @@
 		goto Einval;
 
 	block_group = (ino - 1) / EXT2_INODES_PER_GROUP(sb);
-	gdp = ext2_get_group_desc(sb, block_group, NULL);
+	gdp = ext2_ljj_get_group_desc(sb, block_group, NULL);
 	if (!gdp)
 		goto Egdp;
 	/*
@@ -1318,21 +1318,21 @@
 
 	*p = bh;
 	offset &= (EXT2_BLOCK_SIZE(sb) - 1);
-	return (struct ext2_inode *) (bh->b_data + offset);
+	return (struct ext2_ljj_inode *) (bh->b_data + offset);
 
 Einval:
-	ext2_error(sb, "ext2_get_inode", "bad inode number: %lu",
+	ext2_ljj_error(sb, "ext2_ljj_get_inode", "bad inode number: %lu",
 		   (unsigned long) ino);
 	return ERR_PTR(-EINVAL);
 Eio:
-	ext2_error(sb, "ext2_get_inode",
+	ext2_ljj_error(sb, "ext2_ljj_get_inode",
 		   "unable to read inode block - inode=%lu, block=%lu",
 		   (unsigned long) ino, block);
 Egdp:
 	return ERR_PTR(-EIO);
 }
 
-void ext2_set_inode_flags(struct inode *inode)
+void ext2_ljj_set_inode_flags(struct inode *inode)
 {
 	unsigned int flags = EXT2_I(inode)->i_flags;
 
@@ -1352,21 +1352,21 @@
 		inode->i_flags |= S_DAX;
 }
 
-void ext2_set_file_ops(struct inode *inode)
+void ext2_ljj_set_file_ops(struct inode *inode)
 {
-	inode->i_op = &ext2_file_inode_operations;
-	inode->i_fop = &ext2_file_operations;
+	inode->i_op = &ext2_ljj_file_inode_operations;
+	inode->i_fop = &ext2_ljj_file_operations;
 	if (IS_DAX(inode))
-		inode->i_mapping->a_ops = &ext2_dax_aops;
+		inode->i_mapping->a_ops = &ext2_ljj_dax_aops;
 	else
-		inode->i_mapping->a_ops = &ext2_aops;
+		inode->i_mapping->a_ops = &ext2_ljj_aops;
 }
 
-struct inode *ext2_iget (struct super_block *sb, unsigned long ino)
+struct inode *ext2_ljj_iget (struct super_block *sb, unsigned long ino)
 {
-	struct ext2_inode_info *ei;
+	struct ext2_ljj_inode_info *ei;
 	struct buffer_head * bh = NULL;
-	struct ext2_inode *raw_inode;
+	struct ext2_ljj_inode *raw_inode;
 	struct inode *inode;
 	long ret = -EIO;
 	int n;
@@ -1382,7 +1382,7 @@
 	ei = EXT2_I(inode);
 	ei->i_block_alloc_info = NULL;
 
-	raw_inode = ext2_get_inode(inode->i_sb, ino, &bh);
+	raw_inode = ext2_ljj_get_inode(inode->i_sb, ino, &bh);
 	if (IS_ERR(raw_inode)) {
 		ret = PTR_ERR(raw_inode);
  		goto bad_inode;
@@ -1416,7 +1416,7 @@
 	}
 	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
 	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
-	ext2_set_inode_flags(inode);
+	ext2_ljj_set_inode_flags(inode);
 	ei->i_faddr = le32_to_cpu(raw_inode->i_faddr);
 	ei->i_frag_no = raw_inode->i_frag;
 	ei->i_frag_size = raw_inode->i_fsize;
@@ -1424,8 +1424,8 @@
 	ei->i_dir_acl = 0;
 
 	if (ei->i_file_acl &&
-	    !ext2_data_block_valid(EXT2_SB(sb), ei->i_file_acl, 1)) {
-		ext2_error(sb, "ext2_iget", "bad extended attribute block %u",
+	    !ext2_ljj_data_block_valid(EXT2_SB(sb), ei->i_file_acl, 1)) {
+		ext2_ljj_error(sb, "ext2_ljj_iget", "bad extended attribute block %u",
 			   ei->i_file_acl);
 		ret = -EFSCORRUPTED;
 		goto bad_inode;
@@ -1453,24 +1453,24 @@
 		ei->i_data[n] = raw_inode->i_block[n];
 
 	if (S_ISREG(inode->i_mode)) {
-		ext2_set_file_ops(inode);
+		ext2_ljj_set_file_ops(inode);
 	} else if (S_ISDIR(inode->i_mode)) {
-		inode->i_op = &ext2_dir_inode_operations;
-		inode->i_fop = &ext2_dir_operations;
-		inode->i_mapping->a_ops = &ext2_aops;
+		inode->i_op = &ext2_ljj_dir_inode_operations;
+		inode->i_fop = &ext2_ljj_dir_operations;
+		inode->i_mapping->a_ops = &ext2_ljj_aops;
 	} else if (S_ISLNK(inode->i_mode)) {
-		if (ext2_inode_is_fast_symlink(inode)) {
+		if (ext2_ljj_inode_is_fast_symlink(inode)) {
 			inode->i_link = (char *)ei->i_data;
-			inode->i_op = &ext2_fast_symlink_inode_operations;
+			inode->i_op = &ext2_ljj_fast_symlink_inode_operations;
 			nd_terminate_link(ei->i_data, inode->i_size,
 				sizeof(ei->i_data) - 1);
 		} else {
-			inode->i_op = &ext2_symlink_inode_operations;
+			inode->i_op = &ext2_ljj_symlink_inode_operations;
 			inode_nohighmem(inode);
-			inode->i_mapping->a_ops = &ext2_aops;
+			inode->i_mapping->a_ops = &ext2_ljj_aops;
 		}
 	} else {
-		inode->i_op = &ext2_special_inode_operations;
+		inode->i_op = &ext2_ljj_special_inode_operations;
 		if (raw_inode->i_block[0])
 			init_special_inode(inode, inode->i_mode,
 			   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));
@@ -1488,15 +1488,15 @@
 	return ERR_PTR(ret);
 }
 
-static int __ext2_write_inode(struct inode *inode, int do_sync)
+static int __ext2_ljj_write_inode(struct inode *inode, int do_sync)
 {
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 	struct super_block *sb = inode->i_sb;
 	ino_t ino = inode->i_ino;
 	uid_t uid = i_uid_read(inode);
 	gid_t gid = i_gid_read(inode);
 	struct buffer_head * bh;
-	struct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);
+	struct ext2_ljj_inode * raw_inode = ext2_ljj_get_inode(sb, ino, &bh);
 	int n;
 	int err = 0;
 
@@ -1555,11 +1555,11 @@
 				* created, add a flag to the superblock.
 				*/
 				spin_lock(&EXT2_SB(sb)->s_lock);
-				ext2_update_dynamic_rev(sb);
+				ext2_ljj_update_dynamic_rev(sb);
 				EXT2_SET_RO_COMPAT_FEATURE(sb,
 					EXT2_FEATURE_RO_COMPAT_LARGE_FILE);
 				spin_unlock(&EXT2_SB(sb)->s_lock);
-				ext2_sync_super(sb, EXT2_SB(sb)->s_es, 1);
+				ext2_ljj_sync_super(sb, EXT2_SB(sb)->s_es, 1);
 			}
 		}
 	}
@@ -1582,7 +1582,7 @@
 	if (do_sync) {
 		sync_dirty_buffer(bh);
 		if (buffer_req(bh) && !buffer_uptodate(bh)) {
-			printk ("IO error syncing ext2 inode [%s:%08lx]\n",
+			printk ("IO error syncing ext2_ljj inode [%s:%08lx]\n",
 				sb->s_id, (unsigned long) ino);
 			err = -EIO;
 		}
@@ -1592,16 +1592,16 @@
 	return err;
 }
 
-int ext2_write_inode(struct inode *inode, struct writeback_control *wbc)
+int ext2_ljj_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
-	return __ext2_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
+	return __ext2_ljj_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
 }
 
-int ext2_getattr(struct user_namespace *mnt_userns, const struct path *path,
+int ext2_ljj_getattr(struct user_namespace *mnt_userns, const struct path *path,
 		 struct kstat *stat, u32 request_mask, unsigned int query_flags)
 {
 	struct inode *inode = d_inode(path->dentry);
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 	unsigned int flags;
 
 	flags = ei->i_flags & EXT2_FL_USER_VISIBLE;
@@ -1623,7 +1623,7 @@
 	return 0;
 }
 
-int ext2_setattr(struct user_namespace *mnt_userns, struct dentry *dentry,
+int ext2_ljj_setattr(struct user_namespace *mnt_userns, struct dentry *dentry,
 		 struct iattr *iattr)
 {
 	struct inode *inode = d_inode(dentry);
@@ -1645,7 +1645,7 @@
 			return error;
 	}
 	if (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {
-		error = ext2_setsize(inode, iattr->ia_size);
+		error = ext2_ljj_setsize(inode, iattr->ia_size);
 		if (error)
 			return error;
 	}
diff -urN fs/ext2/ioctl.c fs/ext2_ljj/ioctl.c
--- fs/ext2/ioctl.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/ioctl.c	2024-11-04 11:48:27.266696838 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/ioctl.c
+ * linux/fs/ext2_ljj/ioctl.c
  *
  * Copyright (C) 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -8,7 +8,7 @@
  * Universite Pierre et Marie Curie (Paris VI)
  */
 
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include <linux/capability.h>
 #include <linux/time.h>
 #include <linux/sched.h>
@@ -18,20 +18,20 @@
 #include <linux/uaccess.h>
 #include <linux/fileattr.h>
 
-int ext2_fileattr_get(struct dentry *dentry, struct fileattr *fa)
+int ext2_ljj_fileattr_get(struct dentry *dentry, struct fileattr *fa)
 {
-	struct ext2_inode_info *ei = EXT2_I(d_inode(dentry));
+	struct ext2_ljj_inode_info *ei = EXT2_I(d_inode(dentry));
 
 	fileattr_fill_flags(fa, ei->i_flags & EXT2_FL_USER_VISIBLE);
 
 	return 0;
 }
 
-int ext2_fileattr_set(struct user_namespace *mnt_userns,
+int ext2_ljj_fileattr_set(struct user_namespace *mnt_userns,
 		      struct dentry *dentry, struct fileattr *fa)
 {
 	struct inode *inode = d_inode(dentry);
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 
 	if (fileattr_has_fsx(fa))
 		return -EOPNOTSUPP;
@@ -43,7 +43,7 @@
 	ei->i_flags = (ei->i_flags & ~EXT2_FL_USER_MODIFIABLE) |
 		(fa->flags & EXT2_FL_USER_MODIFIABLE);
 
-	ext2_set_inode_flags(inode);
+	ext2_ljj_set_inode_flags(inode);
 	inode->i_ctime = current_time(inode);
 	mark_inode_dirty(inode);
 
@@ -51,14 +51,14 @@
 }
 
 
-long ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+long ext2_ljj_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct inode *inode = file_inode(filp);
-	struct ext2_inode_info *ei = EXT2_I(inode);
+	struct ext2_ljj_inode_info *ei = EXT2_I(inode);
 	unsigned short rsv_window_size;
 	int ret;
 
-	ext2_debug ("cmd = %u, arg = %lu\n", cmd, arg);
+	ext2_ljj_debug ("cmd = %u, arg = %lu\n", cmd, arg);
 
 	switch (cmd) {
 	case EXT2_IOC_GETVERSION:
@@ -118,14 +118,14 @@
 		 */
 		/*
 		 * XXX What lock should protect the rsv_goal_size?
-		 * Accessed in ext2_get_block only.  ext3 uses i_truncate.
+		 * Accessed in ext2_ljj_get_block only.  ext3 uses i_truncate.
 		 */
 		mutex_lock(&ei->truncate_mutex);
 		if (!ei->i_block_alloc_info)
-			ext2_init_block_alloc_info(inode);
+			ext2_ljj_init_block_alloc_info(inode);
 
 		if (ei->i_block_alloc_info){
-			struct ext2_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;
+			struct ext2_ljj_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;
 			rsv->rsv_goal_size = rsv_window_size;
 		} else {
 			ret = -ENOMEM;
@@ -141,7 +141,7 @@
 }
 
 #ifdef CONFIG_COMPAT
-long ext2_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+long ext2_ljj_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	/* These are just misnamed, they actually get/put from/to user an int */
 	switch (cmd) {
@@ -154,6 +154,6 @@
 	default:
 		return -ENOIOCTLCMD;
 	}
-	return ext2_ioctl(file, cmd, (unsigned long) compat_ptr(arg));
+	return ext2_ljj_ioctl(file, cmd, (unsigned long) compat_ptr(arg));
 }
 #endif
diff -urN fs/ext2/Kconfig fs/ext2_ljj/Kconfig
--- fs/ext2/Kconfig	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/Kconfig	2024-11-04 11:48:27.266696838 +0800
@@ -6,7 +6,7 @@
 	  Ext2 is a standard Linux file system for hard disks.
 
 	  To compile this file system support as a module, choose M here: the
-	  module will be called ext2.
+	  module will be called ext2_ljj.
 
 	  If unsure, say Y.
 
@@ -36,7 +36,7 @@
 	  Security labels support alternative access control models
 	  implemented by security modules like SELinux.  This option
 	  enables an extended attribute handler for file security
-	  labels in the ext2 filesystem.
+	  labels in the ext2_ljj filesystem.
 
 	  If you are not using a security module that requires using
 	  extended attributes for file security labels, say N.
diff -urN fs/ext2/Makefile fs/ext2_ljj/Makefile
--- fs/ext2/Makefile	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/Makefile	2024-11-04 11:48:27.270696556 +0800
@@ -1,13 +1,13 @@
 # SPDX-License-Identifier: GPL-2.0
 #
-# Makefile for the linux ext2-filesystem routines.
+# Makefile for the linux ext2_ljj-filesystem routines.
 #
 
-obj-$(CONFIG_EXT2_FS) += ext2.o
+obj-$(CONFIG_EXT2_FS) += ext2_ljj.o
 
-ext2-y := balloc.o dir.o file.o ialloc.o inode.o \
+ext2_ljj-y := balloc.o dir.o file.o ialloc.o inode.o \
 	  ioctl.o namei.o super.o symlink.o
 
-ext2-$(CONFIG_EXT2_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
-ext2-$(CONFIG_EXT2_FS_POSIX_ACL) += acl.o
-ext2-$(CONFIG_EXT2_FS_SECURITY)	 += xattr_security.o
+ext2_ljj-$(CONFIG_EXT2_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
+ext2_ljj-$(CONFIG_EXT2_FS_POSIX_ACL) += acl.o
+ext2_ljj-$(CONFIG_EXT2_FS_SECURITY)	 += xattr_security.o
diff -urN fs/ext2/.modules.order.cmd fs/ext2_ljj/.modules.order.cmd
--- fs/ext2/.modules.order.cmd	1970-01-01 08:00:00.000000000 +0800
+++ fs/ext2_ljj/.modules.order.cmd	2024-11-04 11:57:04.753910678 +0800
@@ -0,0 +1 @@
+cmd_fs/ext2_ljj/modules.order := {  :; } > fs/ext2_ljj/modules.order
diff -urN fs/ext2/namei.c fs/ext2_ljj/namei.c
--- fs/ext2/namei.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/namei.c	2024-11-04 11:48:27.268696697 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/namei.c
+ * linux/fs/ext2_ljj/namei.c
  *
  * Rewrite to pagecache. Almost all code had been changed, so blame me
  * if the things go wrong. Please, send bug reports to
@@ -8,11 +8,11 @@
  *
  * Stuff here is basically a glue between the VFS and generic UNIXish
  * filesystem that keeps everything in pagecache. All knowledge of the
- * directory layout is in fs/ext2/dir.c - it turned out to be easily separatable
+ * directory layout is in fs/ext2_ljj/dir.c - it turned out to be easily separatable
  * and it's easier to debug that way. In principle we might want to
  * generalize that a bit and turn it into a library. Or not.
  *
- * The only non-static object here is ext2_dir_inode_operations.
+ * The only non-static object here is ext2_ljj_dir_inode_operations.
  *
  * TODO: get rid of kmap() use, add readahead.
  *
@@ -33,13 +33,13 @@
 
 #include <linux/pagemap.h>
 #include <linux/quotaops.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 #include "acl.h"
 
-static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)
+static inline int ext2_ljj_add_nondir(struct dentry *dentry, struct inode *inode)
 {
-	int err = ext2_add_link(dentry, inode);
+	int err = ext2_ljj_add_link(dentry, inode);
 	if (!err) {
 		d_instantiate_new(dentry, inode);
 		return 0;
@@ -53,7 +53,7 @@
  * Methods themselves.
  */
 
-static struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)
+static struct dentry *ext2_ljj_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)
 {
 	struct inode * inode;
 	ino_t ino;
@@ -62,15 +62,15 @@
 	if (dentry->d_name.len > EXT2_NAME_LEN)
 		return ERR_PTR(-ENAMETOOLONG);
 
-	res = ext2_inode_by_name(dir, &dentry->d_name, &ino);
+	res = ext2_ljj_inode_by_name(dir, &dentry->d_name, &ino);
 	if (res) {
 		if (res != -ENOENT)
 			return ERR_PTR(res);
 		inode = NULL;
 	} else {
-		inode = ext2_iget(dir->i_sb, ino);
+		inode = ext2_ljj_iget(dir->i_sb, ino);
 		if (inode == ERR_PTR(-ESTALE)) {
-			ext2_error(dir->i_sb, __func__,
+			ext2_ljj_error(dir->i_sb, __func__,
 					"deleted inode referenced: %lu",
 					(unsigned long) ino);
 			return ERR_PTR(-EIO);
@@ -79,16 +79,16 @@
 	return d_splice_alias(inode, dentry);
 }
 
-struct dentry *ext2_get_parent(struct dentry *child)
+struct dentry *ext2_ljj_get_parent(struct dentry *child)
 {
 	ino_t ino;
 	int res;
 
-	res = ext2_inode_by_name(d_inode(child), &dotdot_name, &ino);
+	res = ext2_ljj_inode_by_name(d_inode(child), &dotdot_name, &ino);
 	if (res)
 		return ERR_PTR(res);
 
-	return d_obtain_alias(ext2_iget(child->d_sb, ino));
+	return d_obtain_alias(ext2_ljj_iget(child->d_sb, ino));
 } 
 
 /*
@@ -99,7 +99,7 @@
  * If the create succeeds, we fill in the inode information
  * with d_instantiate(). 
  */
-static int ext2_create (struct user_namespace * mnt_userns,
+static int ext2_ljj_create (struct user_namespace * mnt_userns,
 			struct inode * dir, struct dentry * dentry,
 			umode_t mode, bool excl)
 {
@@ -110,30 +110,30 @@
 	if (err)
 		return err;
 
-	inode = ext2_new_inode(dir, mode, &dentry->d_name);
+	inode = ext2_ljj_new_inode(dir, mode, &dentry->d_name);
 	if (IS_ERR(inode))
 		return PTR_ERR(inode);
 
-	ext2_set_file_ops(inode);
+	ext2_ljj_set_file_ops(inode);
 	mark_inode_dirty(inode);
-	return ext2_add_nondir(dentry, inode);
+	return ext2_ljj_add_nondir(dentry, inode);
 }
 
-static int ext2_tmpfile(struct user_namespace *mnt_userns, struct inode *dir,
+static int ext2_ljj_tmpfile(struct user_namespace *mnt_userns, struct inode *dir,
 			struct file *file, umode_t mode)
 {
-	struct inode *inode = ext2_new_inode(dir, mode, NULL);
+	struct inode *inode = ext2_ljj_new_inode(dir, mode, NULL);
 	if (IS_ERR(inode))
 		return PTR_ERR(inode);
 
-	ext2_set_file_ops(inode);
+	ext2_ljj_set_file_ops(inode);
 	mark_inode_dirty(inode);
 	d_tmpfile(file, inode);
 	unlock_new_inode(inode);
 	return finish_open_simple(file, 0);
 }
 
-static int ext2_mknod (struct user_namespace * mnt_userns, struct inode * dir,
+static int ext2_ljj_mknod (struct user_namespace * mnt_userns, struct inode * dir,
 	struct dentry *dentry, umode_t mode, dev_t rdev)
 {
 	struct inode * inode;
@@ -143,18 +143,18 @@
 	if (err)
 		return err;
 
-	inode = ext2_new_inode (dir, mode, &dentry->d_name);
+	inode = ext2_ljj_new_inode (dir, mode, &dentry->d_name);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		init_special_inode(inode, inode->i_mode, rdev);
-		inode->i_op = &ext2_special_inode_operations;
+		inode->i_op = &ext2_ljj_special_inode_operations;
 		mark_inode_dirty(inode);
-		err = ext2_add_nondir(dentry, inode);
+		err = ext2_ljj_add_nondir(dentry, inode);
 	}
 	return err;
 }
 
-static int ext2_symlink (struct user_namespace * mnt_userns, struct inode * dir,
+static int ext2_ljj_symlink (struct user_namespace * mnt_userns, struct inode * dir,
 	struct dentry * dentry, const char * symname)
 {
 	struct super_block * sb = dir->i_sb;
@@ -169,29 +169,29 @@
 	if (err)
 		goto out;
 
-	inode = ext2_new_inode (dir, S_IFLNK | S_IRWXUGO, &dentry->d_name);
+	inode = ext2_ljj_new_inode (dir, S_IFLNK | S_IRWXUGO, &dentry->d_name);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out;
 
 	if (l > sizeof (EXT2_I(inode)->i_data)) {
 		/* slow symlink */
-		inode->i_op = &ext2_symlink_inode_operations;
+		inode->i_op = &ext2_ljj_symlink_inode_operations;
 		inode_nohighmem(inode);
-		inode->i_mapping->a_ops = &ext2_aops;
+		inode->i_mapping->a_ops = &ext2_ljj_aops;
 		err = page_symlink(inode, symname, l);
 		if (err)
 			goto out_fail;
 	} else {
 		/* fast symlink */
-		inode->i_op = &ext2_fast_symlink_inode_operations;
+		inode->i_op = &ext2_ljj_fast_symlink_inode_operations;
 		inode->i_link = (char*)EXT2_I(inode)->i_data;
 		memcpy(inode->i_link, symname, l);
 		inode->i_size = l-1;
 	}
 	mark_inode_dirty(inode);
 
-	err = ext2_add_nondir(dentry, inode);
+	err = ext2_ljj_add_nondir(dentry, inode);
 out:
 	return err;
 
@@ -201,7 +201,7 @@
 	goto out;
 }
 
-static int ext2_link (struct dentry * old_dentry, struct inode * dir,
+static int ext2_ljj_link (struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
 	struct inode *inode = d_inode(old_dentry);
@@ -215,7 +215,7 @@
 	inode_inc_link_count(inode);
 	ihold(inode);
 
-	err = ext2_add_link(dentry, inode);
+	err = ext2_ljj_add_link(dentry, inode);
 	if (!err) {
 		d_instantiate(dentry, inode);
 		return 0;
@@ -225,7 +225,7 @@
 	return err;
 }
 
-static int ext2_mkdir(struct user_namespace * mnt_userns,
+static int ext2_ljj_mkdir(struct user_namespace * mnt_userns,
 	struct inode * dir, struct dentry * dentry, umode_t mode)
 {
 	struct inode * inode;
@@ -237,22 +237,22 @@
 
 	inode_inc_link_count(dir);
 
-	inode = ext2_new_inode(dir, S_IFDIR | mode, &dentry->d_name);
+	inode = ext2_ljj_new_inode(dir, S_IFDIR | mode, &dentry->d_name);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_dir;
 
-	inode->i_op = &ext2_dir_inode_operations;
-	inode->i_fop = &ext2_dir_operations;
-	inode->i_mapping->a_ops = &ext2_aops;
+	inode->i_op = &ext2_ljj_dir_inode_operations;
+	inode->i_fop = &ext2_ljj_dir_operations;
+	inode->i_mapping->a_ops = &ext2_ljj_aops;
 
 	inode_inc_link_count(inode);
 
-	err = ext2_make_empty(inode, dir);
+	err = ext2_ljj_make_empty(inode, dir);
 	if (err)
 		goto out_fail;
 
-	err = ext2_add_link(dentry, inode);
+	err = ext2_ljj_add_link(dentry, inode);
 	if (err)
 		goto out_fail;
 
@@ -269,10 +269,10 @@
 	goto out;
 }
 
-static int ext2_unlink(struct inode * dir, struct dentry *dentry)
+static int ext2_ljj_unlink(struct inode * dir, struct dentry *dentry)
 {
 	struct inode * inode = d_inode(dentry);
-	struct ext2_dir_entry_2 * de;
+	struct ext2_ljj_dir_entry_2 * de;
 	struct page * page;
 	void *page_addr;
 	int err;
@@ -281,14 +281,14 @@
 	if (err)
 		goto out;
 
-	de = ext2_find_entry(dir, &dentry->d_name, &page, &page_addr);
+	de = ext2_ljj_find_entry(dir, &dentry->d_name, &page, &page_addr);
 	if (IS_ERR(de)) {
 		err = PTR_ERR(de);
 		goto out;
 	}
 
-	err = ext2_delete_entry (de, page, page_addr);
-	ext2_put_page(page, page_addr);
+	err = ext2_ljj_delete_entry (de, page, page_addr);
+	ext2_ljj_put_page(page, page_addr);
 	if (err)
 		goto out;
 
@@ -299,13 +299,13 @@
 	return err;
 }
 
-static int ext2_rmdir (struct inode * dir, struct dentry *dentry)
+static int ext2_ljj_rmdir (struct inode * dir, struct dentry *dentry)
 {
 	struct inode * inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
-	if (ext2_empty_dir(inode)) {
-		err = ext2_unlink(dir, dentry);
+	if (ext2_ljj_empty_dir(inode)) {
+		err = ext2_ljj_unlink(dir, dentry);
 		if (!err) {
 			inode->i_size = 0;
 			inode_dec_link_count(inode);
@@ -315,7 +315,7 @@
 	return err;
 }
 
-static int ext2_rename (struct user_namespace * mnt_userns,
+static int ext2_ljj_rename (struct user_namespace * mnt_userns,
 			struct inode * old_dir, struct dentry * old_dentry,
 			struct inode * new_dir, struct dentry * new_dentry,
 			unsigned int flags)
@@ -324,10 +324,10 @@
 	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	void *dir_page_addr;
-	struct ext2_dir_entry_2 * dir_de = NULL;
+	struct ext2_ljj_dir_entry_2 * dir_de = NULL;
 	struct page * old_page;
 	void *old_page_addr;
-	struct ext2_dir_entry_2 * old_de;
+	struct ext2_ljj_dir_entry_2 * old_de;
 	int err;
 
 	if (flags & ~RENAME_NOREPLACE)
@@ -341,7 +341,7 @@
 	if (err)
 		goto out;
 
-	old_de = ext2_find_entry(old_dir, &old_dentry->d_name, &old_page,
+	old_de = ext2_ljj_find_entry(old_dir, &old_dentry->d_name, &old_page,
 				 &old_page_addr);
 	if (IS_ERR(old_de)) {
 		err = PTR_ERR(old_de);
@@ -350,7 +350,7 @@
 
 	if (S_ISDIR(old_inode->i_mode)) {
 		err = -EIO;
-		dir_de = ext2_dotdot(old_inode, &dir_page, &dir_page_addr);
+		dir_de = ext2_ljj_dotdot(old_inode, &dir_page, &dir_page_addr);
 		if (!dir_de)
 			goto out_old;
 	}
@@ -358,26 +358,26 @@
 	if (new_inode) {
 		void *page_addr;
 		struct page *new_page;
-		struct ext2_dir_entry_2 *new_de;
+		struct ext2_ljj_dir_entry_2 *new_de;
 
 		err = -ENOTEMPTY;
-		if (dir_de && !ext2_empty_dir (new_inode))
+		if (dir_de && !ext2_ljj_empty_dir (new_inode))
 			goto out_dir;
 
-		new_de = ext2_find_entry(new_dir, &new_dentry->d_name,
+		new_de = ext2_ljj_find_entry(new_dir, &new_dentry->d_name,
 					 &new_page, &page_addr);
 		if (IS_ERR(new_de)) {
 			err = PTR_ERR(new_de);
 			goto out_dir;
 		}
-		ext2_set_link(new_dir, new_de, new_page, page_addr, old_inode, 1);
-		ext2_put_page(new_page, page_addr);
+		ext2_ljj_set_link(new_dir, new_de, new_page, page_addr, old_inode, 1);
+		ext2_ljj_put_page(new_page, page_addr);
 		new_inode->i_ctime = current_time(new_inode);
 		if (dir_de)
 			drop_nlink(new_inode);
 		inode_dec_link_count(new_inode);
 	} else {
-		err = ext2_add_link(new_dentry, old_inode);
+		err = ext2_ljj_add_link(new_dentry, old_inode);
 		if (err)
 			goto out_dir;
 		if (dir_de)
@@ -391,53 +391,53 @@
 	old_inode->i_ctime = current_time(old_inode);
 	mark_inode_dirty(old_inode);
 
-	ext2_delete_entry(old_de, old_page, old_page_addr);
+	ext2_ljj_delete_entry(old_de, old_page, old_page_addr);
 
 	if (dir_de) {
 		if (old_dir != new_dir)
-			ext2_set_link(old_inode, dir_de, dir_page,
+			ext2_ljj_set_link(old_inode, dir_de, dir_page,
 				      dir_page_addr, new_dir, 0);
 
-		ext2_put_page(dir_page, dir_page_addr);
+		ext2_ljj_put_page(dir_page, dir_page_addr);
 		inode_dec_link_count(old_dir);
 	}
 
-	ext2_put_page(old_page, old_page_addr);
+	ext2_ljj_put_page(old_page, old_page_addr);
 	return 0;
 
 out_dir:
 	if (dir_de)
-		ext2_put_page(dir_page, dir_page_addr);
+		ext2_ljj_put_page(dir_page, dir_page_addr);
 out_old:
-	ext2_put_page(old_page, old_page_addr);
+	ext2_ljj_put_page(old_page, old_page_addr);
 out:
 	return err;
 }
 
-const struct inode_operations ext2_dir_inode_operations = {
-	.create		= ext2_create,
-	.lookup		= ext2_lookup,
-	.link		= ext2_link,
-	.unlink		= ext2_unlink,
-	.symlink	= ext2_symlink,
-	.mkdir		= ext2_mkdir,
-	.rmdir		= ext2_rmdir,
-	.mknod		= ext2_mknod,
-	.rename		= ext2_rename,
-	.listxattr	= ext2_listxattr,
-	.getattr	= ext2_getattr,
-	.setattr	= ext2_setattr,
-	.get_acl	= ext2_get_acl,
-	.set_acl	= ext2_set_acl,
-	.tmpfile	= ext2_tmpfile,
-	.fileattr_get	= ext2_fileattr_get,
-	.fileattr_set	= ext2_fileattr_set,
+const struct inode_operations ext2_ljj_dir_inode_operations = {
+	.create		= ext2_ljj_create,
+	.lookup		= ext2_ljj_lookup,
+	.link		= ext2_ljj_link,
+	.unlink		= ext2_ljj_unlink,
+	.symlink	= ext2_ljj_symlink,
+	.mkdir		= ext2_ljj_mkdir,
+	.rmdir		= ext2_ljj_rmdir,
+	.mknod		= ext2_ljj_mknod,
+	.rename		= ext2_ljj_rename,
+	.listxattr	= ext2_ljj_listxattr,
+	.getattr	= ext2_ljj_getattr,
+	.setattr	= ext2_ljj_setattr,
+	.get_acl	= ext2_ljj_get_acl,
+	.set_acl	= ext2_ljj_set_acl,
+	.tmpfile	= ext2_ljj_tmpfile,
+	.fileattr_get	= ext2_ljj_fileattr_get,
+	.fileattr_set	= ext2_ljj_fileattr_set,
 };
 
-const struct inode_operations ext2_special_inode_operations = {
-	.listxattr	= ext2_listxattr,
-	.getattr	= ext2_getattr,
-	.setattr	= ext2_setattr,
-	.get_acl	= ext2_get_acl,
-	.set_acl	= ext2_set_acl,
+const struct inode_operations ext2_ljj_special_inode_operations = {
+	.listxattr	= ext2_ljj_listxattr,
+	.getattr	= ext2_ljj_getattr,
+	.setattr	= ext2_ljj_setattr,
+	.get_acl	= ext2_ljj_get_acl,
+	.set_acl	= ext2_ljj_set_acl,
 };
diff -urN fs/ext2/super.c fs/ext2_ljj/super.c
--- fs/ext2/super.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/super.c	2024-11-04 11:48:27.270696556 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- *  linux/fs/ext2/super.c
+ *  linux/fs/ext2_ljj/super.c
  *
  * Copyright (C) 1992, 1993, 1994, 1995
  * Remy Card (card@masi.ibp.fr)
@@ -35,31 +35,31 @@
 #include <linux/uaccess.h>
 #include <linux/dax.h>
 #include <linux/iversion.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 #include "acl.h"
 
-static void ext2_write_super(struct super_block *sb);
-static int ext2_remount (struct super_block * sb, int * flags, char * data);
-static int ext2_statfs (struct dentry * dentry, struct kstatfs * buf);
-static int ext2_sync_fs(struct super_block *sb, int wait);
-static int ext2_freeze(struct super_block *sb);
-static int ext2_unfreeze(struct super_block *sb);
+static void ext2_ljj_write_super(struct super_block *sb);
+static int ext2_ljj_remount (struct super_block * sb, int * flags, char * data);
+static int ext2_ljj_statfs (struct dentry * dentry, struct kstatfs * buf);
+static int ext2_ljj_sync_fs(struct super_block *sb, int wait);
+static int ext2_ljj_freeze(struct super_block *sb);
+static int ext2_ljj_unfreeze(struct super_block *sb);
 
-void ext2_error(struct super_block *sb, const char *function,
+void ext2_ljj_error(struct super_block *sb, const char *function,
 		const char *fmt, ...)
 {
 	struct va_format vaf;
 	va_list args;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
-	struct ext2_super_block *es = sbi->s_es;
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_super_block *es = sbi->s_es;
 
 	if (!sb_rdonly(sb)) {
 		spin_lock(&sbi->s_lock);
 		sbi->s_mount_state |= EXT2_ERROR_FS;
 		es->s_state |= cpu_to_le16(EXT2_ERROR_FS);
 		spin_unlock(&sbi->s_lock);
-		ext2_sync_super(sb, es, 1);
+		ext2_ljj_sync_super(sb, es, 1);
 	}
 
 	va_start(args, fmt);
@@ -75,13 +75,13 @@
 	if (test_opt(sb, ERRORS_PANIC))
 		panic("EXT2-fs: panic from previous error\n");
 	if (!sb_rdonly(sb) && test_opt(sb, ERRORS_RO)) {
-		ext2_msg(sb, KERN_CRIT,
+		ext2_ljj_msg(sb, KERN_CRIT,
 			     "error: remounting filesystem read-only");
 		sb->s_flags |= SB_RDONLY;
 	}
 }
 
-void ext2_msg(struct super_block *sb, const char *prefix,
+void ext2_ljj_msg(struct super_block *sb, const char *prefix,
 		const char *fmt, ...)
 {
 	struct va_format vaf;
@@ -100,14 +100,14 @@
 /*
  * This must be called with sbi->s_lock held.
  */
-void ext2_update_dynamic_rev(struct super_block *sb)
+void ext2_ljj_update_dynamic_rev(struct super_block *sb)
 {
-	struct ext2_super_block *es = EXT2_SB(sb)->s_es;
+	struct ext2_ljj_super_block *es = EXT2_SB(sb)->s_es;
 
 	if (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)
 		return;
 
-	ext2_msg(sb, KERN_WARNING,
+	ext2_ljj_msg(sb, KERN_WARNING,
 		     "warning: updating to rev %d because of "
 		     "new feature flag, running e2fsck is recommended",
 		     EXT2_DYNAMIC_REV);
@@ -126,39 +126,39 @@
 }
 
 #ifdef CONFIG_QUOTA
-static int ext2_quota_off(struct super_block *sb, int type);
+static int ext2_ljj_quota_off(struct super_block *sb, int type);
 
-static void ext2_quota_off_umount(struct super_block *sb)
+static void ext2_ljj_quota_off_umount(struct super_block *sb)
 {
 	int type;
 
 	for (type = 0; type < MAXQUOTAS; type++)
-		ext2_quota_off(sb, type);
+		ext2_ljj_quota_off(sb, type);
 }
 #else
-static inline void ext2_quota_off_umount(struct super_block *sb)
+static inline void ext2_ljj_quota_off_umount(struct super_block *sb)
 {
 }
 #endif
 
-static void ext2_put_super (struct super_block * sb)
+static void ext2_ljj_put_super (struct super_block * sb)
 {
 	int db_count;
 	int i;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 
-	ext2_quota_off_umount(sb);
+	ext2_ljj_quota_off_umount(sb);
 
-	ext2_xattr_destroy_cache(sbi->s_ea_block_cache);
+	ext2_ljj_xattr_destroy_cache(sbi->s_ea_block_cache);
 	sbi->s_ea_block_cache = NULL;
 
 	if (!sb_rdonly(sb)) {
-		struct ext2_super_block *es = sbi->s_es;
+		struct ext2_ljj_super_block *es = sbi->s_es;
 
 		spin_lock(&sbi->s_lock);
 		es->s_state = cpu_to_le16(sbi->s_mount_state);
 		spin_unlock(&sbi->s_lock);
-		ext2_sync_super(sb, es, 1);
+		ext2_ljj_sync_super(sb, es, 1);
 	}
 	db_count = sbi->s_gdb_count;
 	for (i = 0; i < db_count; i++)
@@ -175,12 +175,12 @@
 	kfree(sbi);
 }
 
-static struct kmem_cache * ext2_inode_cachep;
+static struct kmem_cache * ext2_ljj_inode_cachep;
 
-static struct inode *ext2_alloc_inode(struct super_block *sb)
+static struct inode *ext2_ljj_alloc_inode(struct super_block *sb)
 {
-	struct ext2_inode_info *ei;
-	ei = alloc_inode_sb(sb, ext2_inode_cachep, GFP_KERNEL);
+	struct ext2_ljj_inode_info *ei;
+	ei = alloc_inode_sb(sb, ext2_ljj_inode_cachep, GFP_KERNEL);
 	if (!ei)
 		return NULL;
 	ei->i_block_alloc_info = NULL;
@@ -192,14 +192,14 @@
 	return &ei->vfs_inode;
 }
 
-static void ext2_free_in_core_inode(struct inode *inode)
+static void ext2_ljj_free_in_core_inode(struct inode *inode)
 {
-	kmem_cache_free(ext2_inode_cachep, EXT2_I(inode));
+	kmem_cache_free(ext2_ljj_inode_cachep, EXT2_I(inode));
 }
 
 static void init_once(void *foo)
 {
-	struct ext2_inode_info *ei = (struct ext2_inode_info *) foo;
+	struct ext2_ljj_inode_info *ei = (struct ext2_ljj_inode_info *) foo;
 
 	rwlock_init(&ei->i_meta_lock);
 #ifdef CONFIG_EXT2_FS_XATTR
@@ -211,14 +211,14 @@
 
 static int __init init_inodecache(void)
 {
-	ext2_inode_cachep = kmem_cache_create_usercopy("ext2_inode_cache",
-				sizeof(struct ext2_inode_info), 0,
+	ext2_ljj_inode_cachep = kmem_cache_create_usercopy("ext2_ljj_inode_cache",
+				sizeof(struct ext2_ljj_inode_info), 0,
 				(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|
 					SLAB_ACCOUNT),
-				offsetof(struct ext2_inode_info, i_data),
-				sizeof_field(struct ext2_inode_info, i_data),
+				offsetof(struct ext2_ljj_inode_info, i_data),
+				sizeof_field(struct ext2_ljj_inode_info, i_data),
 				init_once);
-	if (ext2_inode_cachep == NULL)
+	if (ext2_ljj_inode_cachep == NULL)
 		return -ENOMEM;
 	return 0;
 }
@@ -230,14 +230,14 @@
 	 * destroy cache.
 	 */
 	rcu_barrier();
-	kmem_cache_destroy(ext2_inode_cachep);
+	kmem_cache_destroy(ext2_ljj_inode_cachep);
 }
 
-static int ext2_show_options(struct seq_file *seq, struct dentry *root)
+static int ext2_ljj_show_options(struct seq_file *seq, struct dentry *root)
 {
 	struct super_block *sb = root->d_sb;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
-	struct ext2_super_block *es = sbi->s_es;
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_super_block *es = sbi->s_es;
 	unsigned long def_mount_opts;
 
 	spin_lock(&sbi->s_lock);
@@ -316,18 +316,18 @@
 }
 
 #ifdef CONFIG_QUOTA
-static ssize_t ext2_quota_read(struct super_block *sb, int type, char *data, size_t len, loff_t off);
-static ssize_t ext2_quota_write(struct super_block *sb, int type, const char *data, size_t len, loff_t off);
-static int ext2_quota_on(struct super_block *sb, int type, int format_id,
+static ssize_t ext2_ljj_quota_read(struct super_block *sb, int type, char *data, size_t len, loff_t off);
+static ssize_t ext2_ljj_quota_write(struct super_block *sb, int type, const char *data, size_t len, loff_t off);
+static int ext2_ljj_quota_on(struct super_block *sb, int type, int format_id,
 			 const struct path *path);
-static struct dquot **ext2_get_dquots(struct inode *inode)
+static struct dquot **ext2_ljj_get_dquots(struct inode *inode)
 {
 	return EXT2_I(inode)->i_dquot;
 }
 
-static const struct quotactl_ops ext2_quotactl_ops = {
-	.quota_on	= ext2_quota_on,
-	.quota_off	= ext2_quota_off,
+static const struct quotactl_ops ext2_ljj_quotactl_ops = {
+	.quota_on	= ext2_ljj_quota_on,
+	.quota_off	= ext2_ljj_quota_off,
 	.quota_sync	= dquot_quota_sync,
 	.get_state	= dquot_get_state,
 	.set_info	= dquot_set_dqinfo,
@@ -337,26 +337,26 @@
 };
 #endif
 
-static const struct super_operations ext2_sops = {
-	.alloc_inode	= ext2_alloc_inode,
-	.free_inode	= ext2_free_in_core_inode,
-	.write_inode	= ext2_write_inode,
-	.evict_inode	= ext2_evict_inode,
-	.put_super	= ext2_put_super,
-	.sync_fs	= ext2_sync_fs,
-	.freeze_fs	= ext2_freeze,
-	.unfreeze_fs	= ext2_unfreeze,
-	.statfs		= ext2_statfs,
-	.remount_fs	= ext2_remount,
-	.show_options	= ext2_show_options,
+static const struct super_operations ext2_ljj_sops = {
+	.alloc_inode	= ext2_ljj_alloc_inode,
+	.free_inode	= ext2_ljj_free_in_core_inode,
+	.write_inode	= ext2_ljj_write_inode,
+	.evict_inode	= ext2_ljj_evict_inode,
+	.put_super	= ext2_ljj_put_super,
+	.sync_fs	= ext2_ljj_sync_fs,
+	.freeze_fs	= ext2_ljj_freeze,
+	.unfreeze_fs	= ext2_ljj_unfreeze,
+	.statfs		= ext2_ljj_statfs,
+	.remount_fs	= ext2_ljj_remount,
+	.show_options	= ext2_ljj_show_options,
 #ifdef CONFIG_QUOTA
-	.quota_read	= ext2_quota_read,
-	.quota_write	= ext2_quota_write,
-	.get_dquots	= ext2_get_dquots,
+	.quota_read	= ext2_ljj_quota_read,
+	.quota_write	= ext2_ljj_quota_write,
+	.get_dquots	= ext2_ljj_get_dquots,
 #endif
 };
 
-static struct inode *ext2_nfs_get_inode(struct super_block *sb,
+static struct inode *ext2_ljj_nfs_get_inode(struct super_block *sb,
 		u64 ino, u32 generation)
 {
 	struct inode *inode;
@@ -367,11 +367,11 @@
 		return ERR_PTR(-ESTALE);
 
 	/*
-	 * ext2_iget isn't quite right if the inode is currently unallocated!
-	 * However ext2_iget currently does appropriate checks to handle stale
+	 * ext2_ljj_iget isn't quite right if the inode is currently unallocated!
+	 * However ext2_ljj_iget currently does appropriate checks to handle stale
 	 * inodes so everything is OK.
 	 */
-	inode = ext2_iget(sb, ino);
+	inode = ext2_ljj_iget(sb, ino);
 	if (IS_ERR(inode))
 		return ERR_CAST(inode);
 	if (generation && inode->i_generation != generation) {
@@ -382,24 +382,24 @@
 	return inode;
 }
 
-static struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,
+static struct dentry *ext2_ljj_fh_to_dentry(struct super_block *sb, struct fid *fid,
 		int fh_len, int fh_type)
 {
 	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
-				    ext2_nfs_get_inode);
+				    ext2_ljj_nfs_get_inode);
 }
 
-static struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,
+static struct dentry *ext2_ljj_fh_to_parent(struct super_block *sb, struct fid *fid,
 		int fh_len, int fh_type)
 {
 	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
-				    ext2_nfs_get_inode);
+				    ext2_ljj_nfs_get_inode);
 }
 
-static const struct export_operations ext2_export_ops = {
-	.fh_to_dentry = ext2_fh_to_dentry,
-	.fh_to_parent = ext2_fh_to_parent,
-	.get_parent = ext2_get_parent,
+static const struct export_operations ext2_ljj_export_ops = {
+	.fh_to_dentry = ext2_ljj_fh_to_dentry,
+	.fh_to_parent = ext2_ljj_fh_to_parent,
+	.get_parent = ext2_ljj_get_parent,
 };
 
 static unsigned long get_sb_block(void **data)
@@ -465,7 +465,7 @@
 };
 
 static int parse_options(char *options, struct super_block *sb,
-			 struct ext2_mount_options *opts)
+			 struct ext2_ljj_mount_options *opts)
 {
 	char *p;
 	substring_t args[MAX_OPT_ARGS];
@@ -500,7 +500,7 @@
 				return 0;
 			uid = make_kuid(current_user_ns(), option);
 			if (!uid_valid(uid)) {
-				ext2_msg(sb, KERN_ERR, "Invalid uid value %d", option);
+				ext2_ljj_msg(sb, KERN_ERR, "Invalid uid value %d", option);
 				return 0;
 
 			}
@@ -511,7 +511,7 @@
 				return 0;
 			gid = make_kgid(current_user_ns(), option);
 			if (!gid_valid(gid)) {
-				ext2_msg(sb, KERN_ERR, "Invalid gid value %d", option);
+				ext2_ljj_msg(sb, KERN_ERR, "Invalid gid value %d", option);
 				return 0;
 			}
 			opts->s_resgid = gid;
@@ -548,7 +548,7 @@
 			clear_opt (opts->s_mount_opt, OLDALLOC);
 			break;
 		case Opt_nobh:
-			ext2_msg(sb, KERN_INFO,
+			ext2_ljj_msg(sb, KERN_INFO,
 				"nobh option not supported");
 			break;
 #ifdef CONFIG_EXT2_FS_XATTR
@@ -561,7 +561,7 @@
 #else
 		case Opt_user_xattr:
 		case Opt_nouser_xattr:
-			ext2_msg(sb, KERN_INFO, "(no)user_xattr options"
+			ext2_ljj_msg(sb, KERN_INFO, "(no)user_xattr options"
 				"not supported");
 			break;
 #endif
@@ -575,21 +575,21 @@
 #else
 		case Opt_acl:
 		case Opt_noacl:
-			ext2_msg(sb, KERN_INFO,
+			ext2_ljj_msg(sb, KERN_INFO,
 				"(no)acl options not supported");
 			break;
 #endif
 		case Opt_xip:
-			ext2_msg(sb, KERN_INFO, "use dax instead of xip");
+			ext2_ljj_msg(sb, KERN_INFO, "use dax instead of xip");
 			set_opt(opts->s_mount_opt, XIP);
 			fallthrough;
 		case Opt_dax:
 #ifdef CONFIG_FS_DAX
-			ext2_msg(sb, KERN_WARNING,
+			ext2_ljj_msg(sb, KERN_WARNING,
 		"DAX enabled. Warning: EXPERIMENTAL, use at your own risk");
 			set_opt(opts->s_mount_opt, DAX);
 #else
-			ext2_msg(sb, KERN_INFO, "dax option not supported");
+			ext2_ljj_msg(sb, KERN_INFO, "dax option not supported");
 #endif
 			break;
 
@@ -606,18 +606,18 @@
 		case Opt_quota:
 		case Opt_usrquota:
 		case Opt_grpquota:
-			ext2_msg(sb, KERN_INFO,
+			ext2_ljj_msg(sb, KERN_INFO,
 				"quota operations not supported");
 			break;
 #endif
 
 		case Opt_reservation:
 			set_opt(opts->s_mount_opt, RESERVATION);
-			ext2_msg(sb, KERN_INFO, "reservations ON");
+			ext2_ljj_msg(sb, KERN_INFO, "reservations ON");
 			break;
 		case Opt_noreservation:
 			clear_opt(opts->s_mount_opt, RESERVATION);
-			ext2_msg(sb, KERN_INFO, "reservations OFF");
+			ext2_ljj_msg(sb, KERN_INFO, "reservations OFF");
 			break;
 		case Opt_ignore:
 			break;
@@ -628,15 +628,15 @@
 	return 1;
 }
 
-static int ext2_setup_super (struct super_block * sb,
-			      struct ext2_super_block * es,
+static int ext2_ljj_setup_super (struct super_block * sb,
+			      struct ext2_ljj_super_block * es,
 			      int read_only)
 {
 	int res = 0;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 
 	if (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			"error: revision level too high, "
 			"forcing read-only mode");
 		res = SB_RDONLY;
@@ -644,31 +644,31 @@
 	if (read_only)
 		return res;
 	if (!(sbi->s_mount_state & EXT2_VALID_FS))
-		ext2_msg(sb, KERN_WARNING,
+		ext2_ljj_msg(sb, KERN_WARNING,
 			"warning: mounting unchecked fs, "
 			"running e2fsck is recommended");
 	else if ((sbi->s_mount_state & EXT2_ERROR_FS))
-		ext2_msg(sb, KERN_WARNING,
+		ext2_ljj_msg(sb, KERN_WARNING,
 			"warning: mounting fs with errors, "
 			"running e2fsck is recommended");
 	else if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&
 		 le16_to_cpu(es->s_mnt_count) >=
 		 (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))
-		ext2_msg(sb, KERN_WARNING,
+		ext2_ljj_msg(sb, KERN_WARNING,
 			"warning: maximal mount count reached, "
 			"running e2fsck is recommended");
 	else if (le32_to_cpu(es->s_checkinterval) &&
 		(le32_to_cpu(es->s_lastcheck) +
 			le32_to_cpu(es->s_checkinterval) <=
 			ktime_get_real_seconds()))
-		ext2_msg(sb, KERN_WARNING,
+		ext2_ljj_msg(sb, KERN_WARNING,
 			"warning: checktime reached, "
 			"running e2fsck is recommended");
 	if (!le16_to_cpu(es->s_max_mnt_count))
 		es->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);
 	le16_add_cpu(&es->s_mnt_count, 1);
 	if (test_opt (sb, DEBUG))
-		ext2_msg(sb, KERN_INFO, "%s, %s, bs=%lu, gc=%lu, "
+		ext2_ljj_msg(sb, KERN_INFO, "%s, %s, bs=%lu, gc=%lu, "
 			"bpg=%lu, ipg=%lu, mo=%04lx]",
 			EXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,
 			sbi->s_groups_count,
@@ -678,22 +678,22 @@
 	return res;
 }
 
-static int ext2_check_descriptors(struct super_block *sb)
+static int ext2_ljj_check_descriptors(struct super_block *sb)
 {
 	int i;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 
-	ext2_debug ("Checking group descriptors");
+	ext2_ljj_debug ("Checking group descriptors");
 
 	for (i = 0; i < sbi->s_groups_count; i++) {
-		struct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);
-		ext2_fsblk_t first_block = ext2_group_first_block_no(sb, i);
-		ext2_fsblk_t last_block = ext2_group_last_block_no(sb, i);
+		struct ext2_ljj_group_desc *gdp = ext2_ljj_get_group_desc(sb, i, NULL);
+		ext2_ljj_fsblk_t first_block = ext2_ljj_group_first_block_no(sb, i);
+		ext2_ljj_fsblk_t last_block = ext2_ljj_group_last_block_no(sb, i);
 
 		if (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||
 		    le32_to_cpu(gdp->bg_block_bitmap) > last_block)
 		{
-			ext2_error (sb, "ext2_check_descriptors",
+			ext2_ljj_error (sb, "ext2_ljj_check_descriptors",
 				    "Block bitmap for group %d"
 				    " not in group (block %lu)!",
 				    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));
@@ -702,7 +702,7 @@
 		if (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||
 		    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)
 		{
-			ext2_error (sb, "ext2_check_descriptors",
+			ext2_ljj_error (sb, "ext2_ljj_check_descriptors",
 				    "Inode bitmap for group %d"
 				    " not in group (block %lu)!",
 				    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));
@@ -712,7 +712,7 @@
 		    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >
 		    last_block)
 		{
-			ext2_error (sb, "ext2_check_descriptors",
+			ext2_ljj_error (sb, "ext2_ljj_check_descriptors",
 				    "Inode table for group %d"
 				    " not in group (block %lu)!",
 				    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));
@@ -727,7 +727,7 @@
  * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.
  * We need to be 1 filesystem block less than the 2^32 sector limit.
  */
-static loff_t ext2_max_size(int bits)
+static loff_t ext2_ljj_max_size(int bits)
 {
 	loff_t res = EXT2_NDIR_BLOCKS;
 	int meta_blocks;
@@ -788,7 +788,7 @@
 				    unsigned long logic_sb_block,
 				    int nr)
 {
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 	unsigned long bg, first_meta_bg;
 	
 	first_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);
@@ -798,14 +798,14 @@
 		return (logic_sb_block + nr + 1);
 	bg = sbi->s_desc_per_block * nr;
 
-	return ext2_group_first_block_no(sb, bg) + ext2_bg_has_super(sb, bg);
+	return ext2_ljj_group_first_block_no(sb, bg) + ext2_ljj_bg_has_super(sb, bg);
 }
 
-static int ext2_fill_super(struct super_block *sb, void *data, int silent)
+static int ext2_ljj_fill_super(struct super_block *sb, void *data, int silent)
 {
 	struct buffer_head * bh;
-	struct ext2_sb_info * sbi;
-	struct ext2_super_block * es;
+	struct ext2_ljj_sb_info * sbi;
+	struct ext2_ljj_super_block * es;
 	struct inode *root;
 	unsigned long block;
 	unsigned long sb_block = get_sb_block(&data);
@@ -818,7 +818,7 @@
 	int i, j;
 	__le32 features;
 	int err;
-	struct ext2_mount_options opts;
+	struct ext2_ljj_mount_options opts;
 
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi)
@@ -847,7 +847,7 @@
 	 */
 	blocksize = sb_min_blocksize(sb, BLOCK_SIZE);
 	if (!blocksize) {
-		ext2_msg(sb, KERN_ERR, "error: unable to set blocksize");
+		ext2_ljj_msg(sb, KERN_ERR, "error: unable to set blocksize");
 		goto failed_sbi;
 	}
 
@@ -863,19 +863,19 @@
 	}
 
 	if (!(bh = sb_bread(sb, logic_sb_block))) {
-		ext2_msg(sb, KERN_ERR, "error: unable to read superblock");
+		ext2_ljj_msg(sb, KERN_ERR, "error: unable to read superblock");
 		goto failed_sbi;
 	}
 	/*
 	 * Note: s_es must be initialized as soon as possible because
-	 *       some ext2 macro-instructions depend on its value
+	 *       some ext2_ljj macro-instructions depend on its value
 	 */
-	es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);
+	es = (struct ext2_ljj_super_block *) (((char *)bh->b_data) + offset);
 	sbi->s_es = es;
 	sb->s_magic = le16_to_cpu(es->s_magic);
 
 	if (sb->s_magic != EXT2_SUPER_MAGIC)
-		goto cantfind_ext2;
+		goto cantfind_ext2_ljj;
 
 	opts.s_mount_opt = 0;
 	/* Set defaults before we parse the mount options */
@@ -922,7 +922,7 @@
 	    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||
 	     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||
 	     EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))
-		ext2_msg(sb, KERN_WARNING,
+		ext2_ljj_msg(sb, KERN_WARNING,
 			"warning: feature flags set on rev 0 fs, "
 			"running e2fsck is recommended");
 	/*
@@ -932,13 +932,13 @@
 	 */
 	features = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);
 	if (features) {
-		ext2_msg(sb, KERN_ERR,	"error: couldn't mount because of "
+		ext2_ljj_msg(sb, KERN_ERR,	"error: couldn't mount because of "
 		       "unsupported optional features (%x)",
 			le32_to_cpu(features));
 		goto failed_mount;
 	}
 	if (!sb_rdonly(sb) && (features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){
-		ext2_msg(sb, KERN_ERR, "error: couldn't mount RDWR because of "
+		ext2_ljj_msg(sb, KERN_ERR, "error: couldn't mount RDWR because of "
 		       "unsupported optional features (%x)",
 		       le32_to_cpu(features));
 		goto failed_mount;
@@ -946,7 +946,7 @@
 
 	if (le32_to_cpu(es->s_log_block_size) >
 	    (EXT2_MAX_BLOCK_LOG_SIZE - BLOCK_SIZE_BITS)) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			 "Invalid log block size: %u",
 			 le32_to_cpu(es->s_log_block_size));
 		goto failed_mount;
@@ -955,11 +955,11 @@
 
 	if (test_opt(sb, DAX)) {
 		if (!sbi->s_daxdev) {
-			ext2_msg(sb, KERN_ERR,
+			ext2_ljj_msg(sb, KERN_ERR,
 				"DAX unsupported by block device. Turning off DAX.");
 			clear_opt(sbi->s_mount_opt, DAX);
 		} else if (blocksize != PAGE_SIZE) {
-			ext2_msg(sb, KERN_ERR, "unsupported blocksize for DAX\n");
+			ext2_ljj_msg(sb, KERN_ERR, "unsupported blocksize for DAX\n");
 			clear_opt(sbi->s_mount_opt, DAX);
 		}
 	}
@@ -969,7 +969,7 @@
 		brelse(bh);
 
 		if (!sb_set_blocksize(sb, blocksize)) {
-			ext2_msg(sb, KERN_ERR,
+			ext2_ljj_msg(sb, KERN_ERR,
 				"error: bad blocksize %d", blocksize);
 			goto failed_sbi;
 		}
@@ -978,19 +978,19 @@
 		offset = (sb_block*BLOCK_SIZE) % blocksize;
 		bh = sb_bread(sb, logic_sb_block);
 		if(!bh) {
-			ext2_msg(sb, KERN_ERR, "error: couldn't read"
+			ext2_ljj_msg(sb, KERN_ERR, "error: couldn't read"
 				"superblock on 2nd try");
 			goto failed_sbi;
 		}
-		es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);
+		es = (struct ext2_ljj_super_block *) (((char *)bh->b_data) + offset);
 		sbi->s_es = es;
 		if (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {
-			ext2_msg(sb, KERN_ERR, "error: magic mismatch");
+			ext2_ljj_msg(sb, KERN_ERR, "error: magic mismatch");
 			goto failed_mount;
 		}
 	}
 
-	sb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);
+	sb->s_maxbytes = ext2_ljj_max_size(sb->s_blocksize_bits);
 	sb->s_max_links = EXT2_LINK_MAX;
 	sb->s_time_min = S32_MIN;
 	sb->s_time_max = S32_MAX;
@@ -1004,7 +1004,7 @@
 		if ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||
 		    !is_power_of_2(sbi->s_inode_size) ||
 		    (sbi->s_inode_size > blocksize)) {
-			ext2_msg(sb, KERN_ERR,
+			ext2_ljj_msg(sb, KERN_ERR,
 				"error: unsupported inode size: %d",
 				sbi->s_inode_size);
 			goto failed_mount;
@@ -1016,11 +1016,11 @@
 
 	sbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);
 	if (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)
-		goto cantfind_ext2;
+		goto cantfind_ext2_ljj;
 	sbi->s_itb_per_group = sbi->s_inodes_per_group /
 					sbi->s_inodes_per_block;
 	sbi->s_desc_per_block = sb->s_blocksize /
-					sizeof (struct ext2_group_desc);
+					sizeof (struct ext2_ljj_group_desc);
 	sbi->s_sbh = bh;
 	sbi->s_mount_state = le16_to_cpu(es->s_state);
 	sbi->s_addr_per_block_bits =
@@ -1029,43 +1029,43 @@
 		ilog2 (EXT2_DESC_PER_BLOCK(sb));
 
 	if (sb->s_magic != EXT2_SUPER_MAGIC)
-		goto cantfind_ext2;
+		goto cantfind_ext2_ljj;
 
 	if (sb->s_blocksize != bh->b_size) {
 		if (!silent)
-			ext2_msg(sb, KERN_ERR, "error: unsupported blocksize");
+			ext2_ljj_msg(sb, KERN_ERR, "error: unsupported blocksize");
 		goto failed_mount;
 	}
 
 	if (es->s_log_frag_size != es->s_log_block_size) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			"error: fragsize log %u != blocksize log %u",
 			le32_to_cpu(es->s_log_frag_size), sb->s_blocksize_bits);
 		goto failed_mount;
 	}
 
 	if (sbi->s_blocks_per_group > sb->s_blocksize * 8) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			"error: #blocks per group too big: %lu",
 			sbi->s_blocks_per_group);
 		goto failed_mount;
 	}
 	/* At least inode table, bitmaps, and sb have to fit in one group */
 	if (sbi->s_blocks_per_group <= sbi->s_itb_per_group + 3) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			"error: #blocks per group smaller than metadata size: %lu <= %lu",
 			sbi->s_blocks_per_group, sbi->s_inodes_per_group + 3);
 		goto failed_mount;
 	}
 	if (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||
 	    sbi->s_inodes_per_group > sb->s_blocksize * 8) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			"error: invalid #inodes per group: %lu",
 			sbi->s_inodes_per_group);
 		goto failed_mount;
 	}
 	if (sb_bdev_nr_blocks(sb) < le32_to_cpu(es->s_blocks_count)) {
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 			 "bad geometry: block count %u exceeds size of device (%u blocks)",
 			 le32_to_cpu(es->s_blocks_count),
 			 (unsigned)sb_bdev_nr_blocks(sb));
@@ -1077,7 +1077,7 @@
 					/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;
 	if ((u64)sbi->s_groups_count * sbi->s_inodes_per_group !=
 	    le32_to_cpu(es->s_inodes_count)) {
-		ext2_msg(sb, KERN_ERR, "error: invalid #inodes: %u vs computed %llu",
+		ext2_ljj_msg(sb, KERN_ERR, "error: invalid #inodes: %u vs computed %llu",
 			 le32_to_cpu(es->s_inodes_count),
 			 (u64)sbi->s_groups_count * sbi->s_inodes_per_group);
 		goto failed_mount;
@@ -1089,14 +1089,14 @@
 					   GFP_KERNEL);
 	if (sbi->s_group_desc == NULL) {
 		ret = -ENOMEM;
-		ext2_msg(sb, KERN_ERR, "error: not enough memory");
+		ext2_ljj_msg(sb, KERN_ERR, "error: not enough memory");
 		goto failed_mount;
 	}
 	bgl_lock_init(sbi->s_blockgroup_lock);
 	sbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);
 	if (!sbi->s_debts) {
 		ret = -ENOMEM;
-		ext2_msg(sb, KERN_ERR, "error: not enough memory");
+		ext2_ljj_msg(sb, KERN_ERR, "error: not enough memory");
 		goto failed_mount_group_desc;
 	}
 	for (i = 0; i < db_count; i++) {
@@ -1105,13 +1105,13 @@
 		if (!sbi->s_group_desc[i]) {
 			for (j = 0; j < i; j++)
 				brelse (sbi->s_group_desc[j]);
-			ext2_msg(sb, KERN_ERR,
+			ext2_ljj_msg(sb, KERN_ERR,
 				"error: unable to read group descriptors");
 			goto failed_mount_group_desc;
 		}
 	}
-	if (!ext2_check_descriptors (sb)) {
-		ext2_msg(sb, KERN_ERR, "group descriptors corrupted");
+	if (!ext2_ljj_check_descriptors (sb)) {
+		ext2_ljj_msg(sb, KERN_ERR, "group descriptors corrupted");
 		goto failed_mount2;
 	}
 	sbi->s_gdb_count = db_count;
@@ -1131,78 +1131,78 @@
 	sbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;
 	sbi->s_rsv_window_head.rsv_alloc_hit = 0;
 	sbi->s_rsv_window_head.rsv_goal_size = 0;
-	ext2_rsv_window_add(sb, &sbi->s_rsv_window_head);
+	ext2_ljj_rsv_window_add(sb, &sbi->s_rsv_window_head);
 
 	err = percpu_counter_init(&sbi->s_freeblocks_counter,
-				ext2_count_free_blocks(sb), GFP_KERNEL);
+				ext2_ljj_count_free_blocks(sb), GFP_KERNEL);
 	if (!err) {
 		err = percpu_counter_init(&sbi->s_freeinodes_counter,
-				ext2_count_free_inodes(sb), GFP_KERNEL);
+				ext2_ljj_count_free_inodes(sb), GFP_KERNEL);
 	}
 	if (!err) {
 		err = percpu_counter_init(&sbi->s_dirs_counter,
-				ext2_count_dirs(sb), GFP_KERNEL);
+				ext2_ljj_count_dirs(sb), GFP_KERNEL);
 	}
 	if (err) {
 		ret = err;
-		ext2_msg(sb, KERN_ERR, "error: insufficient memory");
+		ext2_ljj_msg(sb, KERN_ERR, "error: insufficient memory");
 		goto failed_mount3;
 	}
 
 #ifdef CONFIG_EXT2_FS_XATTR
-	sbi->s_ea_block_cache = ext2_xattr_create_cache();
+	sbi->s_ea_block_cache = ext2_ljj_xattr_create_cache();
 	if (!sbi->s_ea_block_cache) {
 		ret = -ENOMEM;
-		ext2_msg(sb, KERN_ERR, "Failed to create ea_block_cache");
+		ext2_ljj_msg(sb, KERN_ERR, "Failed to create ea_block_cache");
 		goto failed_mount3;
 	}
 #endif
 	/*
 	 * set up enough so that it can read an inode
 	 */
-	sb->s_op = &ext2_sops;
-	sb->s_export_op = &ext2_export_ops;
-	sb->s_xattr = ext2_xattr_handlers;
+	sb->s_op = &ext2_ljj_sops;
+	sb->s_export_op = &ext2_ljj_export_ops;
+	sb->s_xattr = ext2_ljj_xattr_handlers;
 
 #ifdef CONFIG_QUOTA
 	sb->dq_op = &dquot_operations;
-	sb->s_qcop = &ext2_quotactl_ops;
+	sb->s_qcop = &ext2_ljj_quotactl_ops;
 	sb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;
 #endif
 
-	root = ext2_iget(sb, EXT2_ROOT_INO);
+	root = ext2_ljj_iget(sb, EXT2_ROOT_INO);
 	if (IS_ERR(root)) {
 		ret = PTR_ERR(root);
 		goto failed_mount3;
 	}
 	if (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {
 		iput(root);
-		ext2_msg(sb, KERN_ERR, "error: corrupt root inode, run e2fsck");
+		ext2_ljj_msg(sb, KERN_ERR, "error: corrupt root inode, run e2fsck");
 		goto failed_mount3;
 	}
 
 	sb->s_root = d_make_root(root);
 	if (!sb->s_root) {
-		ext2_msg(sb, KERN_ERR, "error: get root inode failed");
+		ext2_ljj_msg(sb, KERN_ERR, "error: get root inode failed");
 		ret = -ENOMEM;
 		goto failed_mount3;
 	}
 	if (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))
-		ext2_msg(sb, KERN_WARNING,
-			"warning: mounting ext3 filesystem as ext2");
-	if (ext2_setup_super (sb, es, sb_rdonly(sb)))
+		ext2_ljj_msg(sb, KERN_WARNING,
+			"warning: mounting ext3 filesystem as ext2_ljj");
+	if (ext2_ljj_setup_super (sb, es, sb_rdonly(sb)))
 		sb->s_flags |= SB_RDONLY;
-	ext2_write_super(sb);
+	ext2_ljj_write_super(sb);
 	return 0;
 
-cantfind_ext2:
+cantfind_ext2_ljj:
 	if (!silent)
-		ext2_msg(sb, KERN_ERR,
-			"error: can't find an ext2 filesystem on dev %s.",
+		ext2_ljj_msg(sb, KERN_ERR,
+			"error: can't find an ext2_ljj filesystem on dev %s.",
 			sb->s_id);
 	goto failed_mount;
 failed_mount3:
-	ext2_xattr_destroy_cache(sbi->s_ea_block_cache);
+	ext2_ljj_xattr_destroy_cache(sbi->s_ea_block_cache);
 	percpu_counter_destroy(&sbi->s_freeblocks_counter);
 	percpu_counter_destroy(&sbi->s_freeinodes_counter);
 	percpu_counter_destroy(&sbi->s_dirs_counter);
@@ -1222,7 +1222,7 @@
 	return ret;
 }
 
-static void ext2_clear_super_error(struct super_block *sb)
+static void ext2_ljj_clear_super_error(struct super_block *sb)
 {
 	struct buffer_head *sbh = EXT2_SB(sb)->s_sbh;
 
@@ -1235,20 +1235,20 @@
 		 * be remapped.  Nothing we can do but to retry the
 		 * write and hope for the best.
 		 */
-		ext2_msg(sb, KERN_ERR,
+		ext2_ljj_msg(sb, KERN_ERR,
 		       "previous I/O error to superblock detected");
 		clear_buffer_write_io_error(sbh);
 		set_buffer_uptodate(sbh);
 	}
 }
 
-void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,
+void ext2_ljj_sync_super(struct super_block *sb, struct ext2_ljj_super_block *es,
 		     int wait)
 {
-	ext2_clear_super_error(sb);
+	ext2_ljj_clear_super_error(sb);
 	spin_lock(&EXT2_SB(sb)->s_lock);
-	es->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));
-	es->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));
+	es->s_free_blocks_count = cpu_to_le32(ext2_ljj_count_free_blocks(sb));
+	es->s_free_inodes_count = cpu_to_le32(ext2_ljj_count_free_inodes(sb));
 	es->s_wtime = cpu_to_le32(ktime_get_real_seconds());
 	/* unlock before we do IO */
 	spin_unlock(&EXT2_SB(sb)->s_lock);
@@ -1267,10 +1267,10 @@
  * may have been checked while mounted and e2fsck may have
  * set s_state to EXT2_VALID_FS after some corrections.
  */
-static int ext2_sync_fs(struct super_block *sb, int wait)
+static int ext2_ljj_sync_fs(struct super_block *sb, int wait)
 {
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
-	struct ext2_super_block *es = EXT2_SB(sb)->s_es;
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_super_block *es = EXT2_SB(sb)->s_es;
 
 	/*
 	 * Write quota structures to quota file, sync_blockdev() will write
@@ -1280,17 +1280,17 @@
 
 	spin_lock(&sbi->s_lock);
 	if (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {
-		ext2_debug("setting valid to 0\n");
+		ext2_ljj_debug("setting valid to 0\n");
 		es->s_state &= cpu_to_le16(~EXT2_VALID_FS);
 	}
 	spin_unlock(&sbi->s_lock);
-	ext2_sync_super(sb, es, wait);
+	ext2_ljj_sync_super(sb, es, wait);
 	return 0;
 }
 
-static int ext2_freeze(struct super_block *sb)
+static int ext2_ljj_freeze(struct super_block *sb)
 {
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
 
 	/*
 	 * Open but unlinked files present? Keep EXT2_VALID_FS flag cleared
@@ -1298,37 +1298,37 @@
 	 * consistent.
 	 */
 	if (atomic_long_read(&sb->s_remove_count)) {
-		ext2_sync_fs(sb, 1);
+		ext2_ljj_sync_fs(sb, 1);
 		return 0;
 	}
 	/* Set EXT2_FS_VALID flag */
 	spin_lock(&sbi->s_lock);
 	sbi->s_es->s_state = cpu_to_le16(sbi->s_mount_state);
 	spin_unlock(&sbi->s_lock);
-	ext2_sync_super(sb, sbi->s_es, 1);
+	ext2_ljj_sync_super(sb, sbi->s_es, 1);
 
 	return 0;
 }
 
-static int ext2_unfreeze(struct super_block *sb)
+static int ext2_ljj_unfreeze(struct super_block *sb)
 {
 	/* Just write sb to clear EXT2_VALID_FS flag */
-	ext2_write_super(sb);
+	ext2_ljj_write_super(sb);
 
 	return 0;
 }
 
-static void ext2_write_super(struct super_block *sb)
+static void ext2_ljj_write_super(struct super_block *sb)
 {
 	if (!sb_rdonly(sb))
-		ext2_sync_fs(sb, 1);
+		ext2_ljj_sync_fs(sb, 1);
 }
 
-static int ext2_remount (struct super_block * sb, int * flags, char * data)
+static int ext2_ljj_remount (struct super_block * sb, int * flags, char * data)
 {
-	struct ext2_sb_info * sbi = EXT2_SB(sb);
-	struct ext2_super_block * es;
-	struct ext2_mount_options new_opts;
+	struct ext2_ljj_sb_info * sbi = EXT2_SB(sb);
+	struct ext2_ljj_super_block * es;
+	struct ext2_ljj_mount_options new_opts;
 	int err;
 
 	sync_filesystem(sb);
@@ -1345,7 +1345,7 @@
 	spin_lock(&sbi->s_lock);
 	es = sbi->s_es;
 	if ((sbi->s_mount_opt ^ new_opts.s_mount_opt) & EXT2_MOUNT_DAX) {
-		ext2_msg(sb, KERN_WARNING, "warning: refusing change of "
+		ext2_ljj_msg(sb, KERN_WARNING, "warning: refusing change of "
 			 "dax flag with busy inodes while remounting");
 		new_opts.s_mount_opt ^= EXT2_MOUNT_DAX;
 	}
@@ -1368,13 +1368,13 @@
 		if (err < 0)
 			return err;
 
-		ext2_sync_super(sb, es, 1);
+		ext2_ljj_sync_super(sb, es, 1);
 	} else {
 		__le32 ret = EXT2_HAS_RO_COMPAT_FEATURE(sb,
 					       ~EXT2_FEATURE_RO_COMPAT_SUPP);
 		if (ret) {
 			spin_unlock(&sbi->s_lock);
-			ext2_msg(sb, KERN_WARNING,
+			ext2_ljj_msg(sb, KERN_WARNING,
 				"warning: couldn't remount RDWR because of "
 				"unsupported optional features (%x).",
 				le32_to_cpu(ret));
@@ -1386,11 +1386,11 @@
 		 * by e2fsck since we originally mounted the partition.)
 		 */
 		sbi->s_mount_state = le16_to_cpu(es->s_state);
-		if (!ext2_setup_super (sb, es, 0))
+		if (!ext2_ljj_setup_super (sb, es, 0))
 			sb->s_flags &= ~SB_RDONLY;
 		spin_unlock(&sbi->s_lock);
 
-		ext2_write_super(sb);
+		ext2_ljj_write_super(sb);
 
 		dquot_resume(sb, -1);
 	}
@@ -1407,11 +1407,11 @@
 	return 0;
 }
 
-static int ext2_statfs (struct dentry * dentry, struct kstatfs * buf)
+static int ext2_ljj_statfs (struct dentry * dentry, struct kstatfs * buf)
 {
 	struct super_block *sb = dentry->d_sb;
-	struct ext2_sb_info *sbi = EXT2_SB(sb);
-	struct ext2_super_block *es = sbi->s_es;
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(sb);
+	struct ext2_ljj_super_block *es = sbi->s_es;
 
 	spin_lock(&sbi->s_lock);
 
@@ -1439,8 +1439,8 @@
 		 * feature is turned on, then not all groups have this.
 		 */
 		for (i = 0; i < sbi->s_groups_count; i++)
-			overhead += ext2_bg_has_super(sb, i) +
-				ext2_bg_num_gdb(sb, i);
+			overhead += ext2_ljj_bg_has_super(sb, i) +
+				ext2_ljj_bg_num_gdb(sb, i);
 
 		/*
 		 * Every block group has an inode bitmap, a block
@@ -1456,13 +1456,13 @@
 	buf->f_type = EXT2_SUPER_MAGIC;
 	buf->f_bsize = sb->s_blocksize;
 	buf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;
-	buf->f_bfree = ext2_count_free_blocks(sb);
+	buf->f_bfree = ext2_ljj_count_free_blocks(sb);
 	es->s_free_blocks_count = cpu_to_le32(buf->f_bfree);
 	buf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);
 	if (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))
 		buf->f_bavail = 0;
 	buf->f_files = le32_to_cpu(es->s_inodes_count);
-	buf->f_ffree = ext2_count_free_inodes(sb);
+	buf->f_ffree = ext2_ljj_count_free_inodes(sb);
 	es->s_free_inodes_count = cpu_to_le32(buf->f_ffree);
 	buf->f_namelen = EXT2_NAME_LEN;
 	buf->f_fsid = uuid_to_fsid(es->s_uuid);
@@ -1470,10 +1470,10 @@
 	return 0;
 }
 
-static struct dentry *ext2_mount(struct file_system_type *fs_type,
+static struct dentry *ext2_ljj_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
-	return mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);
+	return mount_bdev(fs_type, flags, dev_name, data, ext2_ljj_fill_super);
 }
 
 #ifdef CONFIG_QUOTA
@@ -1482,7 +1482,7 @@
  * acquiring the locks... As quota files are never truncated and quota code
  * itself serializes the operations (and no one else should touch the files)
  * we don't have to be afraid of races */
-static ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,
+static ssize_t ext2_ljj_quota_read(struct super_block *sb, int type, char *data,
 			       size_t len, loff_t off)
 {
 	struct inode *inode = sb_dqopt(sb)->files[type];
@@ -1505,7 +1505,7 @@
 
 		tmp_bh.b_state = 0;
 		tmp_bh.b_size = sb->s_blocksize;
-		err = ext2_get_block(inode, blk, &tmp_bh, 0);
+		err = ext2_ljj_get_block(inode, blk, &tmp_bh, 0);
 		if (err < 0)
 			return err;
 		if (!buffer_mapped(&tmp_bh))	/* A hole? */
@@ -1526,7 +1526,7 @@
 }
 
 /* Write to quotafile */
-static ssize_t ext2_quota_write(struct super_block *sb, int type,
+static ssize_t ext2_ljj_quota_write(struct super_block *sb, int type,
 				const char *data, size_t len, loff_t off)
 {
 	struct inode *inode = sb_dqopt(sb)->files[type];
@@ -1543,7 +1543,7 @@
 
 		tmp_bh.b_state = 0;
 		tmp_bh.b_size = sb->s_blocksize;
-		err = ext2_get_block(inode, blk, &tmp_bh, 1);
+		err = ext2_ljj_get_block(inode, blk, &tmp_bh, 1);
 		if (err < 0)
 			goto out;
 		if (offset || tocopy != EXT2_BLOCK_SIZE(sb))
@@ -1577,7 +1577,7 @@
 	return len - towrite;
 }
 
-static int ext2_quota_on(struct super_block *sb, int type, int format_id,
+static int ext2_ljj_quota_on(struct super_block *sb, int type, int format_id,
 			 const struct path *path)
 {
 	int err;
@@ -1598,7 +1598,7 @@
 	return 0;
 }
 
-static int ext2_quota_off(struct super_block *sb, int type)
+static int ext2_ljj_quota_off(struct super_block *sb, int type)
 {
 	struct inode *inode = sb_dqopt(sb)->files[type];
 	int err;
@@ -1624,23 +1624,23 @@
 
 #endif
 
-static struct file_system_type ext2_fs_type = {
+static struct file_system_type ext2_ljj_fs_type = {
 	.owner		= THIS_MODULE,
-	.name		= "ext2",
-	.mount		= ext2_mount,
+	.name		= "ext2_ljj",
+	.mount		= ext2_ljj_mount,
 	.kill_sb	= kill_block_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };
-MODULE_ALIAS_FS("ext2");
+MODULE_ALIAS_FS("ext2_ljj");
 
-static int __init init_ext2_fs(void)
+static int __init init_ext2_ljj_fs(void)
 {
 	int err;
 
 	err = init_inodecache();
 	if (err)
 		return err;
-        err = register_filesystem(&ext2_fs_type);
+        err = register_filesystem(&ext2_ljj_fs_type);
 	if (err)
 		goto out;
 	return 0;
@@ -1649,14 +1649,14 @@
 	return err;
 }
 
-static void __exit exit_ext2_fs(void)
+static void __exit exit_ext2_ljj_fs(void)
 {
-	unregister_filesystem(&ext2_fs_type);
+	unregister_filesystem(&ext2_ljj_fs_type);
 	destroy_inodecache();
 }
 
 MODULE_AUTHOR("Remy Card and others");
 MODULE_DESCRIPTION("Second Extended Filesystem");
 MODULE_LICENSE("GPL");
-module_init(init_ext2_fs)
-module_exit(exit_ext2_fs)
+module_init(init_ext2_ljj_fs)
+module_exit(exit_ext2_ljj_fs)
diff -urN fs/ext2/symlink.c fs/ext2_ljj/symlink.c
--- fs/ext2/symlink.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/symlink.c	2024-11-04 11:48:27.265696908 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *  linux/fs/ext2/symlink.c
+ *  linux/fs/ext2_ljj/symlink.c
  *
  * Only fast symlinks left here - the rest is done by generic code. AV, 1999
  *
@@ -15,22 +15,22 @@
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
  *
- *  ext2 symlink handling code
+ *  ext2_ljj symlink handling code
  */
 
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 
-const struct inode_operations ext2_symlink_inode_operations = {
+const struct inode_operations ext2_ljj_symlink_inode_operations = {
 	.get_link	= page_get_link,
-	.getattr	= ext2_getattr,
-	.setattr	= ext2_setattr,
-	.listxattr	= ext2_listxattr,
+	.getattr	= ext2_ljj_getattr,
+	.setattr	= ext2_ljj_setattr,
+	.listxattr	= ext2_ljj_listxattr,
 };
  
-const struct inode_operations ext2_fast_symlink_inode_operations = {
+const struct inode_operations ext2_ljj_fast_symlink_inode_operations = {
 	.get_link	= simple_get_link,
-	.getattr	= ext2_getattr,
-	.setattr	= ext2_setattr,
-	.listxattr	= ext2_listxattr,
+	.getattr	= ext2_ljj_getattr,
+	.setattr	= ext2_ljj_setattr,
+	.listxattr	= ext2_ljj_listxattr,
 };
diff -urN fs/ext2/xattr.c fs/ext2_ljj/xattr.c
--- fs/ext2/xattr.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/xattr.c	2024-11-04 11:48:27.271696485 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/xattr.c
+ * linux/fs/ext2_ljj/xattr.c
  *
  * Copyright (C) 2001-2003 Andreas Gruenbacher <agruen@suse.de>
  *
@@ -62,12 +62,12 @@
 #include <linux/quotaops.h>
 #include <linux/rwsem.h>
 #include <linux/security.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 #include "acl.h"
 
-#define HDR(bh) ((struct ext2_xattr_header *)((bh)->b_data))
-#define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))
+#define HDR(bh) ((struct ext2_ljj_xattr_header *)((bh)->b_data))
+#define ENTRY(ptr) ((struct ext2_ljj_xattr_entry *)(ptr))
 #define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
 #define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
 
@@ -89,36 +89,36 @@
 # define ea_bdebug(bh, f...)	no_printk(f)
 #endif
 
-static int ext2_xattr_set2(struct inode *, struct buffer_head *,
-			   struct ext2_xattr_header *);
+static int ext2_ljj_xattr_set2(struct inode *, struct buffer_head *,
+			   struct ext2_ljj_xattr_header *);
 
-static int ext2_xattr_cache_insert(struct mb_cache *, struct buffer_head *);
-static struct buffer_head *ext2_xattr_cache_find(struct inode *,
-						 struct ext2_xattr_header *);
-static void ext2_xattr_rehash(struct ext2_xattr_header *,
-			      struct ext2_xattr_entry *);
+static int ext2_ljj_xattr_cache_insert(struct mb_cache *, struct buffer_head *);
+static struct buffer_head *ext2_ljj_xattr_cache_find(struct inode *,
+						 struct ext2_ljj_xattr_header *);
+static void ext2_ljj_xattr_rehash(struct ext2_ljj_xattr_header *,
+			      struct ext2_ljj_xattr_entry *);
 
-static const struct xattr_handler *ext2_xattr_handler_map[] = {
-	[EXT2_XATTR_INDEX_USER]		     = &ext2_xattr_user_handler,
+static const struct xattr_handler *ext2_ljj_xattr_handler_map[] = {
+	[EXT2_XATTR_INDEX_USER]		     = &ext2_ljj_xattr_user_handler,
 #ifdef CONFIG_EXT2_FS_POSIX_ACL
 	[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,
 	[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,
 #endif
-	[EXT2_XATTR_INDEX_TRUSTED]	     = &ext2_xattr_trusted_handler,
+	[EXT2_XATTR_INDEX_TRUSTED]	     = &ext2_ljj_xattr_trusted_handler,
 #ifdef CONFIG_EXT2_FS_SECURITY
-	[EXT2_XATTR_INDEX_SECURITY]	     = &ext2_xattr_security_handler,
+	[EXT2_XATTR_INDEX_SECURITY]	     = &ext2_ljj_xattr_security_handler,
 #endif
 };
 
-const struct xattr_handler *ext2_xattr_handlers[] = {
-	&ext2_xattr_user_handler,
-	&ext2_xattr_trusted_handler,
+const struct xattr_handler *ext2_ljj_xattr_handlers[] = {
+	&ext2_ljj_xattr_user_handler,
+	&ext2_ljj_xattr_trusted_handler,
 #ifdef CONFIG_EXT2_FS_POSIX_ACL
 	&posix_acl_access_xattr_handler,
 	&posix_acl_default_xattr_handler,
 #endif
 #ifdef CONFIG_EXT2_FS_SECURITY
-	&ext2_xattr_security_handler,
+	&ext2_ljj_xattr_security_handler,
 #endif
 	NULL
 };
@@ -126,17 +126,17 @@
 #define EA_BLOCK_CACHE(inode)	(EXT2_SB(inode->i_sb)->s_ea_block_cache)
 
 static inline const struct xattr_handler *
-ext2_xattr_handler(int name_index)
+ext2_ljj_xattr_handler(int name_index)
 {
 	const struct xattr_handler *handler = NULL;
 
-	if (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))
-		handler = ext2_xattr_handler_map[name_index];
+	if (name_index > 0 && name_index < ARRAY_SIZE(ext2_ljj_xattr_handler_map))
+		handler = ext2_ljj_xattr_handler_map[name_index];
 	return handler;
 }
 
 static bool
-ext2_xattr_header_valid(struct ext2_xattr_header *header)
+ext2_ljj_xattr_header_valid(struct ext2_ljj_xattr_header *header)
 {
 	if (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||
 	    header->h_blocks != cpu_to_le32(1))
@@ -146,10 +146,10 @@
 }
 
 static bool
-ext2_xattr_entry_valid(struct ext2_xattr_entry *entry,
+ext2_ljj_xattr_entry_valid(struct ext2_ljj_xattr_entry *entry,
 		       char *end, size_t end_offs)
 {
-	struct ext2_xattr_entry *next;
+	struct ext2_ljj_xattr_entry *next;
 	size_t size;
 
 	next = EXT2_XATTR_NEXT(entry);
@@ -168,8 +168,8 @@
 }
 
 static int
-ext2_xattr_cmp_entry(int name_index, size_t name_len, const char *name,
-		     struct ext2_xattr_entry *entry)
+ext2_ljj_xattr_cmp_entry(int name_index, size_t name_len, const char *name,
+		     struct ext2_ljj_xattr_entry *entry)
 {
 	int cmp;
 
@@ -183,7 +183,7 @@
 }
 
 /*
- * ext2_xattr_get()
+ * ext2_ljj_xattr_get()
  *
  * Copy an extended attribute into the buffer
  * provided, or compute the buffer size required.
@@ -193,11 +193,11 @@
  * used / required on success.
  */
 int
-ext2_xattr_get(struct inode *inode, int name_index, const char *name,
+ext2_ljj_xattr_get(struct inode *inode, int name_index, const char *name,
 	       void *buffer, size_t buffer_size)
 {
 	struct buffer_head *bh = NULL;
-	struct ext2_xattr_entry *entry;
+	struct ext2_ljj_xattr_entry *entry;
 	size_t name_len, size;
 	char *end;
 	int error, not_found;
@@ -224,9 +224,9 @@
 	ea_bdebug(bh, "b_count=%d, refcount=%d",
 		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
 	end = bh->b_data + bh->b_size;
-	if (!ext2_xattr_header_valid(HDR(bh))) {
+	if (!ext2_ljj_xattr_header_valid(HDR(bh))) {
 bad_block:
-		ext2_error(inode->i_sb, "ext2_xattr_get",
+		ext2_ljj_error(inode->i_sb, "ext2_ljj_xattr_get",
 			"inode %ld: bad block %d", inode->i_ino,
 			EXT2_I(inode)->i_file_acl);
 		error = -EIO;
@@ -236,11 +236,11 @@
 	/* find named attribute */
 	entry = FIRST_ENTRY(bh);
 	while (!IS_LAST_ENTRY(entry)) {
-		if (!ext2_xattr_entry_valid(entry, end,
+		if (!ext2_ljj_xattr_entry_valid(entry, end,
 		    inode->i_sb->s_blocksize))
 			goto bad_block;
 
-		not_found = ext2_xattr_cmp_entry(name_index, name_len, name,
+		not_found = ext2_ljj_xattr_cmp_entry(name_index, name_len, name,
 						 entry);
 		if (!not_found)
 			goto found;
@@ -249,13 +249,13 @@
 
 		entry = EXT2_XATTR_NEXT(entry);
 	}
-	if (ext2_xattr_cache_insert(ea_block_cache, bh))
+	if (ext2_ljj_xattr_cache_insert(ea_block_cache, bh))
 		ea_idebug(inode, "cache insert failed");
 	error = -ENODATA;
 	goto cleanup;
 found:
 	size = le32_to_cpu(entry->e_value_size);
-	if (ext2_xattr_cache_insert(ea_block_cache, bh))
+	if (ext2_ljj_xattr_cache_insert(ea_block_cache, bh))
 		ea_idebug(inode, "cache insert failed");
 	if (buffer) {
 		error = -ERANGE;
@@ -275,7 +275,7 @@
 }
 
 /*
- * ext2_xattr_list()
+ * ext2_ljj_xattr_list()
  *
  * Copy a list of attribute names into the buffer
  * provided, or compute the buffer size required.
@@ -285,11 +285,11 @@
  * used / required on success.
  */
 static int
-ext2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
+ext2_ljj_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
 	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
-	struct ext2_xattr_entry *entry;
+	struct ext2_ljj_xattr_entry *entry;
 	char *end;
 	size_t rest = buffer_size;
 	int error;
@@ -310,9 +310,9 @@
 	ea_bdebug(bh, "b_count=%d, refcount=%d",
 		atomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));
 	end = bh->b_data + bh->b_size;
-	if (!ext2_xattr_header_valid(HDR(bh))) {
+	if (!ext2_ljj_xattr_header_valid(HDR(bh))) {
 bad_block:
-		ext2_error(inode->i_sb, "ext2_xattr_list",
+		ext2_ljj_error(inode->i_sb, "ext2_ljj_xattr_list",
 			"inode %ld: bad block %d", inode->i_ino,
 			EXT2_I(inode)->i_file_acl);
 		error = -EIO;
@@ -322,19 +322,19 @@
 	/* check the on-disk data structure */
 	entry = FIRST_ENTRY(bh);
 	while (!IS_LAST_ENTRY(entry)) {
-		if (!ext2_xattr_entry_valid(entry, end,
+		if (!ext2_ljj_xattr_entry_valid(entry, end,
 		    inode->i_sb->s_blocksize))
 			goto bad_block;
 		entry = EXT2_XATTR_NEXT(entry);
 	}
-	if (ext2_xattr_cache_insert(ea_block_cache, bh))
+	if (ext2_ljj_xattr_cache_insert(ea_block_cache, bh))
 		ea_idebug(inode, "cache insert failed");
 
 	/* list the attribute names */
 	for (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);
 	     entry = EXT2_XATTR_NEXT(entry)) {
 		const struct xattr_handler *handler =
-			ext2_xattr_handler(entry->e_name_index);
+			ext2_ljj_xattr_handler(entry->e_name_index);
 
 		if (handler && (!handler->list || handler->list(dentry))) {
 			const char *prefix = handler->prefix ?: handler->name;
@@ -370,29 +370,29 @@
  * d_inode(dentry)->i_mutex: don't care
  */
 ssize_t
-ext2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+ext2_ljj_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	return ext2_xattr_list(dentry, buffer, size);
+	return ext2_ljj_xattr_list(dentry, buffer, size);
 }
 
 /*
  * If the EXT2_FEATURE_COMPAT_EXT_ATTR feature of this file system is
  * not set, set it.
  */
-static void ext2_xattr_update_super_block(struct super_block *sb)
+static void ext2_ljj_xattr_update_super_block(struct super_block *sb)
 {
 	if (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))
 		return;
 
 	spin_lock(&EXT2_SB(sb)->s_lock);
-	ext2_update_dynamic_rev(sb);
+	ext2_ljj_update_dynamic_rev(sb);
 	EXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);
 	spin_unlock(&EXT2_SB(sb)->s_lock);
 	mark_buffer_dirty(EXT2_SB(sb)->s_sbh);
 }
 
 /*
- * ext2_xattr_set()
+ * ext2_ljj_xattr_set()
  *
  * Create, replace or remove an extended attribute for this inode.  Value
  * is NULL to remove an existing extended attribute, and non-NULL to
@@ -404,13 +404,13 @@
  * Returns 0, or a negative error number on failure.
  */
 int
-ext2_xattr_set(struct inode *inode, int name_index, const char *name,
+ext2_ljj_xattr_set(struct inode *inode, int name_index, const char *name,
 	       const void *value, size_t value_len, int flags)
 {
 	struct super_block *sb = inode->i_sb;
 	struct buffer_head *bh = NULL;
-	struct ext2_xattr_header *header = NULL;
-	struct ext2_xattr_entry *here = NULL, *last = NULL;
+	struct ext2_ljj_xattr_header *header = NULL;
+	struct ext2_ljj_xattr_entry *here = NULL, *last = NULL;
 	size_t name_len, free, min_offs = sb->s_blocksize;
 	int not_found = 1, error;
 	char *end;
@@ -452,9 +452,9 @@
 			le32_to_cpu(HDR(bh)->h_refcount));
 		header = HDR(bh);
 		end = bh->b_data + bh->b_size;
-		if (!ext2_xattr_header_valid(header)) {
+		if (!ext2_ljj_xattr_header_valid(header)) {
 bad_block:
-			ext2_error(sb, "ext2_xattr_set",
+			ext2_ljj_error(sb, "ext2_ljj_xattr_set",
 				"inode %ld: bad block %d", inode->i_ino, 
 				   EXT2_I(inode)->i_file_acl);
 			error = -EIO;
@@ -467,7 +467,7 @@
 		 */
 		last = FIRST_ENTRY(bh);
 		while (!IS_LAST_ENTRY(last)) {
-			if (!ext2_xattr_entry_valid(last, end, sb->s_blocksize))
+			if (!ext2_ljj_xattr_entry_valid(last, end, sb->s_blocksize))
 				goto bad_block;
 			if (last->e_value_size) {
 				size_t offs = le16_to_cpu(last->e_value_offs);
@@ -475,7 +475,7 @@
 					min_offs = offs;
 			}
 			if (not_found > 0) {
-				not_found = ext2_xattr_cmp_entry(name_index,
+				not_found = ext2_ljj_xattr_cmp_entry(name_index,
 								 name_len,
 								 name, last);
 				if (not_found <= 0)
@@ -491,7 +491,7 @@
 	} else {
 		/* We will use a new extended attribute block. */
 		free = sb->s_blocksize -
-			sizeof(struct ext2_xattr_header) - sizeof(__u32);
+			sizeof(struct ext2_ljj_xattr_header) - sizeof(__u32);
 	}
 
 	if (not_found) {
@@ -635,12 +635,12 @@
 		/* This block is now empty. */
 		if (bh && header == HDR(bh))
 			unlock_buffer(bh);  /* we were modifying in-place. */
-		error = ext2_xattr_set2(inode, bh, NULL);
+		error = ext2_ljj_xattr_set2(inode, bh, NULL);
 	} else {
-		ext2_xattr_rehash(header, here);
+		ext2_ljj_xattr_rehash(header, here);
 		if (bh && header == HDR(bh))
 			unlock_buffer(bh);  /* we were modifying in-place. */
-		error = ext2_xattr_set2(inode, bh, header);
+		error = ext2_ljj_xattr_set2(inode, bh, header);
 	}
 
 cleanup:
@@ -652,7 +652,7 @@
 	return error;
 }
 
-static void ext2_xattr_release_block(struct inode *inode,
+static void ext2_ljj_xattr_release_block(struct inode *inode,
 				     struct buffer_head *bh)
 {
 	struct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);
@@ -665,7 +665,7 @@
 
 		/*
 		 * This must happen under buffer lock to properly
-		 * serialize with ext2_xattr_set() reusing the block.
+		 * serialize with ext2_ljj_xattr_set() reusing the block.
 		 */
 		oe = mb_cache_entry_delete_or_get(ea_block_cache, hash,
 						  bh->b_blocknr);
@@ -682,7 +682,7 @@
 
 		/* Free the old block. */
 		ea_bdebug(bh, "freeing");
-		ext2_free_blocks(inode, bh->b_blocknr, 1);
+		ext2_ljj_free_blocks(inode, bh->b_blocknr, 1);
 		/* We let our caller release bh, so we
 		 * need to duplicate the buffer before. */
 		get_bh(bh);
@@ -702,11 +702,11 @@
 }
 
 /*
- * Second half of ext2_xattr_set(): Update the file system.
+ * Second half of ext2_ljj_xattr_set(): Update the file system.
  */
 static int
-ext2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,
-		struct ext2_xattr_header *header)
+ext2_ljj_xattr_set2(struct inode *inode, struct buffer_head *old_bh,
+		struct ext2_ljj_xattr_header *header)
 {
 	struct super_block *sb = inode->i_sb;
 	struct buffer_head *new_bh = NULL;
@@ -714,7 +714,7 @@
 	struct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);
 
 	if (header) {
-		new_bh = ext2_xattr_cache_find(inode, header);
+		new_bh = ext2_ljj_xattr_cache_find(inode, header);
 		if (new_bh) {
 			/* We found an identical block in the cache. */
 			if (new_bh == old_bh) {
@@ -739,19 +739,19 @@
 			   don't need to change the reference count. */
 			new_bh = old_bh;
 			get_bh(new_bh);
-			ext2_xattr_cache_insert(ea_block_cache, new_bh);
+			ext2_ljj_xattr_cache_insert(ea_block_cache, new_bh);
 		} else {
 			/* We need to allocate a new block */
-			ext2_fsblk_t goal = ext2_group_first_block_no(sb,
+			ext2_ljj_fsblk_t goal = ext2_ljj_group_first_block_no(sb,
 						EXT2_I(inode)->i_block_group);
-			ext2_fsblk_t block = ext2_new_block(inode, goal, &error);
+			ext2_ljj_fsblk_t block = ext2_ljj_new_block(inode, goal, &error);
 			if (error)
 				goto cleanup;
 			ea_idebug(inode, "creating block %lu", block);
 
 			new_bh = sb_getblk(sb, block);
 			if (unlikely(!new_bh)) {
-				ext2_free_blocks(inode, block, 1);
+				ext2_ljj_free_blocks(inode, block, 1);
 				mark_inode_dirty(inode);
 				error = -ENOMEM;
 				goto cleanup;
@@ -760,9 +760,9 @@
 			memcpy(new_bh->b_data, header, new_bh->b_size);
 			set_buffer_uptodate(new_bh);
 			unlock_buffer(new_bh);
-			ext2_xattr_cache_insert(ea_block_cache, new_bh);
+			ext2_ljj_xattr_cache_insert(ea_block_cache, new_bh);
 			
-			ext2_xattr_update_super_block(sb);
+			ext2_ljj_xattr_update_super_block(sb);
 		}
 		mark_buffer_dirty(new_bh);
 		if (IS_SYNC(inode)) {
@@ -797,7 +797,7 @@
 		 * If there was an old block and we are no longer using it,
 		 * release the old block.
 		 */
-		ext2_xattr_release_block(inode, old_bh);
+		ext2_ljj_xattr_release_block(inode, old_bh);
 	}
 
 cleanup:
@@ -807,16 +807,16 @@
 }
 
 /*
- * ext2_xattr_delete_inode()
+ * ext2_ljj_xattr_delete_inode()
  *
  * Free extended attribute resources associated with this inode. This
  * is called immediately before an inode is freed.
  */
 void
-ext2_xattr_delete_inode(struct inode *inode)
+ext2_ljj_xattr_delete_inode(struct inode *inode)
 {
 	struct buffer_head *bh = NULL;
-	struct ext2_sb_info *sbi = EXT2_SB(inode->i_sb);
+	struct ext2_ljj_sb_info *sbi = EXT2_SB(inode->i_sb);
 
 	/*
 	 * We are the only ones holding inode reference. The xattr_sem should
@@ -830,8 +830,8 @@
 	if (!EXT2_I(inode)->i_file_acl)
 		goto cleanup;
 
-	if (!ext2_data_block_valid(sbi, EXT2_I(inode)->i_file_acl, 1)) {
-		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+	if (!ext2_ljj_data_block_valid(sbi, EXT2_I(inode)->i_file_acl, 1)) {
+		ext2_ljj_error(inode->i_sb, "ext2_ljj_xattr_delete_inode",
 			"inode %ld: xattr block %d is out of data blocks range",
 			inode->i_ino, EXT2_I(inode)->i_file_acl);
 		goto cleanup;
@@ -839,19 +839,19 @@
 
 	bh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);
 	if (!bh) {
-		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+		ext2_ljj_error(inode->i_sb, "ext2_ljj_xattr_delete_inode",
 			"inode %ld: block %d read error", inode->i_ino,
 			EXT2_I(inode)->i_file_acl);
 		goto cleanup;
 	}
 	ea_bdebug(bh, "b_count=%d", atomic_read(&(bh->b_count)));
-	if (!ext2_xattr_header_valid(HDR(bh))) {
-		ext2_error(inode->i_sb, "ext2_xattr_delete_inode",
+	if (!ext2_ljj_xattr_header_valid(HDR(bh))) {
+		ext2_ljj_error(inode->i_sb, "ext2_ljj_xattr_delete_inode",
 			"inode %ld: bad block %d", inode->i_ino,
 			EXT2_I(inode)->i_file_acl);
 		goto cleanup;
 	}
-	ext2_xattr_release_block(inode, bh);
+	ext2_ljj_xattr_release_block(inode, bh);
 	EXT2_I(inode)->i_file_acl = 0;
 
 cleanup:
@@ -860,7 +860,7 @@
 }
 
 /*
- * ext2_xattr_cache_insert()
+ * ext2_ljj_xattr_cache_insert()
  *
  * Create a new entry in the extended attribute cache, and insert
  * it unless such an entry is already in the cache.
@@ -868,7 +868,7 @@
  * Returns 0, or a negative error number on failure.
  */
 static int
-ext2_xattr_cache_insert(struct mb_cache *cache, struct buffer_head *bh)
+ext2_ljj_xattr_cache_insert(struct mb_cache *cache, struct buffer_head *bh)
 {
 	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
 	int error;
@@ -886,7 +886,7 @@
 }
 
 /*
- * ext2_xattr_cmp()
+ * ext2_ljj_xattr_cmp()
  *
  * Compare two extended attribute blocks for equality.
  *
@@ -894,10 +894,10 @@
  * a negative error number on errors.
  */
 static int
-ext2_xattr_cmp(struct ext2_xattr_header *header1,
-	       struct ext2_xattr_header *header2)
+ext2_ljj_xattr_cmp(struct ext2_ljj_xattr_header *header1,
+	       struct ext2_ljj_xattr_header *header2)
 {
-	struct ext2_xattr_entry *entry1, *entry2;
+	struct ext2_ljj_xattr_entry *entry1, *entry2;
 
 	entry1 = ENTRY(header1+1);
 	entry2 = ENTRY(header2+1);
@@ -926,7 +926,7 @@
 }
 
 /*
- * ext2_xattr_cache_find()
+ * ext2_ljj_xattr_cache_find()
  *
  * Find an identical extended attribute block.
  *
@@ -934,7 +934,7 @@
  * a block was not found or an error occurred.
  */
 static struct buffer_head *
-ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)
+ext2_ljj_xattr_cache_find(struct inode *inode, struct ext2_ljj_xattr_header *header)
 {
 	__u32 hash = le32_to_cpu(header->h_hash);
 	struct mb_cache_entry *ce;
@@ -950,7 +950,7 @@
 
 		bh = sb_bread(inode->i_sb, ce->e_value);
 		if (!bh) {
-			ext2_error(inode->i_sb, "ext2_xattr_cache_find",
+			ext2_ljj_error(inode->i_sb, "ext2_ljj_xattr_cache_find",
 				"inode %ld: block %ld read error",
 				inode->i_ino, (unsigned long) ce->e_value);
 		} else {
@@ -961,7 +961,7 @@
 					  (unsigned long) ce->e_value,
 					  le32_to_cpu(HDR(bh)->h_refcount),
 					  EXT2_XATTR_REFCOUNT_MAX);
-			} else if (!ext2_xattr_cmp(header, HDR(bh))) {
+			} else if (!ext2_ljj_xattr_cmp(header, HDR(bh))) {
 				ea_bdebug(bh, "b_count=%d",
 					  atomic_read(&(bh->b_count)));
 				mb_cache_entry_touch(ea_block_cache, ce);
@@ -980,12 +980,12 @@
 #define VALUE_HASH_SHIFT 16
 
 /*
- * ext2_xattr_hash_entry()
+ * ext2_ljj_xattr_hash_entry()
  *
  * Compute the hash of an extended attribute.
  */
-static inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,
-					 struct ext2_xattr_entry *entry)
+static inline void ext2_ljj_xattr_hash_entry(struct ext2_ljj_xattr_header *header,
+					 struct ext2_ljj_xattr_entry *entry)
 {
 	__u32 hash = 0;
 	char *name = entry->e_name;
@@ -1016,17 +1016,17 @@
 #define BLOCK_HASH_SHIFT 16
 
 /*
- * ext2_xattr_rehash()
+ * ext2_ljj_xattr_rehash()
  *
  * Re-compute the extended attribute hash value after an entry has changed.
  */
-static void ext2_xattr_rehash(struct ext2_xattr_header *header,
-			      struct ext2_xattr_entry *entry)
+static void ext2_ljj_xattr_rehash(struct ext2_ljj_xattr_header *header,
+			      struct ext2_ljj_xattr_entry *entry)
 {
-	struct ext2_xattr_entry *here;
+	struct ext2_ljj_xattr_entry *here;
 	__u32 hash = 0;
 	
-	ext2_xattr_hash_entry(header, entry);
+	ext2_ljj_xattr_hash_entry(header, entry);
 	here = ENTRY(header+1);
 	while (!IS_LAST_ENTRY(here)) {
 		if (!here->e_hash) {
@@ -1046,12 +1046,12 @@
 
 #define HASH_BUCKET_BITS 10
 
-struct mb_cache *ext2_xattr_create_cache(void)
+struct mb_cache *ext2_ljj_xattr_create_cache(void)
 {
 	return mb_cache_create(HASH_BUCKET_BITS);
 }
 
-void ext2_xattr_destroy_cache(struct mb_cache *cache)
+void ext2_ljj_xattr_destroy_cache(struct mb_cache *cache)
 {
 	if (cache)
 		mb_cache_destroy(cache);
diff -urN fs/ext2/xattr.h fs/ext2_ljj/xattr.h
--- fs/ext2/xattr.h	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/xattr.h	2024-11-04 11:48:27.271696485 +0800
@@ -1,8 +1,8 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
-  File: linux/ext2_xattr.h
+  File: linux/ext2_ljj_xattr.h
 
-  On-disk format of extended attributes for the ext2 filesystem.
+  On-disk format of extended attributes for the ext2_ljj filesystem.
 
   (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
 */
@@ -24,7 +24,7 @@
 #define	EXT2_XATTR_INDEX_LUSTRE			5
 #define EXT2_XATTR_INDEX_SECURITY	        6
 
-struct ext2_xattr_header {
+struct ext2_ljj_xattr_header {
 	__le32	h_magic;	/* magic number for identification */
 	__le32	h_refcount;	/* reference count */
 	__le32	h_blocks;	/* number of disk blocks used */
@@ -32,7 +32,7 @@
 	__u32	h_reserved[4];	/* zero right now */
 };
 
-struct ext2_xattr_entry {
+struct ext2_ljj_xattr_entry {
 	__u8	e_name_len;	/* length of name */
 	__u8	e_name_index;	/* attribute name index */
 	__le16	e_value_offs;	/* offset in disk block of value */
@@ -47,9 +47,9 @@
 #define EXT2_XATTR_ROUND		(EXT2_XATTR_PAD-1)
 #define EXT2_XATTR_LEN(name_len) \
 	(((name_len) + EXT2_XATTR_ROUND + \
-	sizeof(struct ext2_xattr_entry)) & ~EXT2_XATTR_ROUND)
+	sizeof(struct ext2_ljj_xattr_entry)) & ~EXT2_XATTR_ROUND)
 #define EXT2_XATTR_NEXT(entry) \
-	( (struct ext2_xattr_entry *)( \
+	( (struct ext2_ljj_xattr_entry *)( \
 	  (char *)(entry) + EXT2_XATTR_LEN((entry)->e_name_len)) )
 #define EXT2_XATTR_SIZE(size) \
 	(((size) + EXT2_XATTR_ROUND) & ~EXT2_XATTR_ROUND)
@@ -58,57 +58,57 @@
 
 # ifdef CONFIG_EXT2_FS_XATTR
 
-extern const struct xattr_handler ext2_xattr_user_handler;
-extern const struct xattr_handler ext2_xattr_trusted_handler;
-extern const struct xattr_handler ext2_xattr_security_handler;
+extern const struct xattr_handler ext2_ljj_xattr_user_handler;
+extern const struct xattr_handler ext2_ljj_xattr_trusted_handler;
+extern const struct xattr_handler ext2_ljj_xattr_security_handler;
 
-extern ssize_t ext2_listxattr(struct dentry *, char *, size_t);
+extern ssize_t ext2_ljj_listxattr(struct dentry *, char *, size_t);
 
-extern int ext2_xattr_get(struct inode *, int, const char *, void *, size_t);
-extern int ext2_xattr_set(struct inode *, int, const char *, const void *, size_t, int);
+extern int ext2_ljj_xattr_get(struct inode *, int, const char *, void *, size_t);
+extern int ext2_ljj_xattr_set(struct inode *, int, const char *, const void *, size_t, int);
 
-extern void ext2_xattr_delete_inode(struct inode *);
+extern void ext2_ljj_xattr_delete_inode(struct inode *);
 
-extern struct mb_cache *ext2_xattr_create_cache(void);
-extern void ext2_xattr_destroy_cache(struct mb_cache *cache);
+extern struct mb_cache *ext2_ljj_xattr_create_cache(void);
+extern void ext2_ljj_xattr_destroy_cache(struct mb_cache *cache);
 
-extern const struct xattr_handler *ext2_xattr_handlers[];
+extern const struct xattr_handler *ext2_ljj_xattr_handlers[];
 
 # else  /* CONFIG_EXT2_FS_XATTR */
 
 static inline int
-ext2_xattr_get(struct inode *inode, int name_index,
+ext2_ljj_xattr_get(struct inode *inode, int name_index,
 	       const char *name, void *buffer, size_t size)
 {
 	return -EOPNOTSUPP;
 }
 
 static inline int
-ext2_xattr_set(struct inode *inode, int name_index, const char *name,
+ext2_ljj_xattr_set(struct inode *inode, int name_index, const char *name,
 	       const void *value, size_t size, int flags)
 {
 	return -EOPNOTSUPP;
 }
 
 static inline void
-ext2_xattr_delete_inode(struct inode *inode)
+ext2_ljj_xattr_delete_inode(struct inode *inode)
 {
 }
 
-static inline void ext2_xattr_destroy_cache(struct mb_cache *cache)
+static inline void ext2_ljj_xattr_destroy_cache(struct mb_cache *cache)
 {
 }
 
-#define ext2_xattr_handlers NULL
-#define ext2_listxattr NULL
+#define ext2_ljj_xattr_handlers NULL
+#define ext2_ljj_listxattr NULL
 
 # endif  /* CONFIG_EXT2_FS_XATTR */
 
 #ifdef CONFIG_EXT2_FS_SECURITY
-extern int ext2_init_security(struct inode *inode, struct inode *dir,
+extern int ext2_ljj_init_security(struct inode *inode, struct inode *dir,
 			      const struct qstr *qstr);
 #else
-static inline int ext2_init_security(struct inode *inode, struct inode *dir,
+static inline int ext2_ljj_init_security(struct inode *inode, struct inode *dir,
 				     const struct qstr *qstr)
 {
 	return 0;
diff -urN fs/ext2/xattr_security.c fs/ext2_ljj/xattr_security.c
--- fs/ext2/xattr_security.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/xattr_security.c	2024-11-04 11:48:27.271696485 +0800
@@ -1,41 +1,41 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/xattr_security.c
+ * linux/fs/ext2_ljj/xattr_security.c
  * Handler for storing security labels as extended attributes.
  */
 
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include <linux/security.h>
 #include "xattr.h"
 
 static int
-ext2_xattr_security_get(const struct xattr_handler *handler,
+ext2_ljj_xattr_security_get(const struct xattr_handler *handler,
 			struct dentry *unused, struct inode *inode,
 			const char *name, void *buffer, size_t size)
 {
-	return ext2_xattr_get(inode, EXT2_XATTR_INDEX_SECURITY, name,
+	return ext2_ljj_xattr_get(inode, EXT2_XATTR_INDEX_SECURITY, name,
 			      buffer, size);
 }
 
 static int
-ext2_xattr_security_set(const struct xattr_handler *handler,
+ext2_ljj_xattr_security_set(const struct xattr_handler *handler,
 			struct user_namespace *mnt_userns,
 			struct dentry *unused, struct inode *inode,
 			const char *name, const void *value,
 			size_t size, int flags)
 {
-	return ext2_xattr_set(inode, EXT2_XATTR_INDEX_SECURITY, name,
+	return ext2_ljj_xattr_set(inode, EXT2_XATTR_INDEX_SECURITY, name,
 			      value, size, flags);
 }
 
-static int ext2_initxattrs(struct inode *inode, const struct xattr *xattr_array,
+static int ext2_ljj_initxattrs(struct inode *inode, const struct xattr *xattr_array,
 			   void *fs_info)
 {
 	const struct xattr *xattr;
 	int err = 0;
 
 	for (xattr = xattr_array; xattr->name != NULL; xattr++) {
-		err = ext2_xattr_set(inode, EXT2_XATTR_INDEX_SECURITY,
+		err = ext2_ljj_xattr_set(inode, EXT2_XATTR_INDEX_SECURITY,
 				     xattr->name, xattr->value,
 				     xattr->value_len, 0);
 		if (err < 0)
@@ -45,15 +45,15 @@
 }
 
 int
-ext2_init_security(struct inode *inode, struct inode *dir,
+ext2_ljj_init_security(struct inode *inode, struct inode *dir,
 		   const struct qstr *qstr)
 {
 	return security_inode_init_security(inode, dir, qstr,
-					    &ext2_initxattrs, NULL);
+					    &ext2_ljj_initxattrs, NULL);
 }
 
-const struct xattr_handler ext2_xattr_security_handler = {
+const struct xattr_handler ext2_ljj_xattr_security_handler = {
 	.prefix	= XATTR_SECURITY_PREFIX,
-	.get	= ext2_xattr_security_get,
-	.set	= ext2_xattr_security_set,
+	.get	= ext2_ljj_xattr_security_get,
+	.set	= ext2_ljj_xattr_security_set,
 };
diff -urN fs/ext2/xattr_trusted.c fs/ext2_ljj/xattr_trusted.c
--- fs/ext2/xattr_trusted.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/xattr_trusted.c	2024-11-04 11:48:27.269696626 +0800
@@ -1,43 +1,43 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/xattr_trusted.c
+ * linux/fs/ext2_ljj/xattr_trusted.c
  * Handler for trusted extended attributes.
  *
  * Copyright (C) 2003 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
  */
 
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 
 static bool
-ext2_xattr_trusted_list(struct dentry *dentry)
+ext2_ljj_xattr_trusted_list(struct dentry *dentry)
 {
 	return capable(CAP_SYS_ADMIN);
 }
 
 static int
-ext2_xattr_trusted_get(const struct xattr_handler *handler,
+ext2_ljj_xattr_trusted_get(const struct xattr_handler *handler,
 		       struct dentry *unused, struct inode *inode,
 		       const char *name, void *buffer, size_t size)
 {
-	return ext2_xattr_get(inode, EXT2_XATTR_INDEX_TRUSTED, name,
+	return ext2_ljj_xattr_get(inode, EXT2_XATTR_INDEX_TRUSTED, name,
 			      buffer, size);
 }
 
 static int
-ext2_xattr_trusted_set(const struct xattr_handler *handler,
+ext2_ljj_xattr_trusted_set(const struct xattr_handler *handler,
 		       struct user_namespace *mnt_userns,
 		       struct dentry *unused, struct inode *inode,
 		       const char *name, const void *value,
 		       size_t size, int flags)
 {
-	return ext2_xattr_set(inode, EXT2_XATTR_INDEX_TRUSTED, name,
+	return ext2_ljj_xattr_set(inode, EXT2_XATTR_INDEX_TRUSTED, name,
 			      value, size, flags);
 }
 
-const struct xattr_handler ext2_xattr_trusted_handler = {
+const struct xattr_handler ext2_ljj_xattr_trusted_handler = {
 	.prefix	= XATTR_TRUSTED_PREFIX,
-	.list	= ext2_xattr_trusted_list,
-	.get	= ext2_xattr_trusted_get,
-	.set	= ext2_xattr_trusted_set,
+	.list	= ext2_ljj_xattr_trusted_list,
+	.get	= ext2_ljj_xattr_trusted_get,
+	.set	= ext2_ljj_xattr_trusted_set,
 };
diff -urN fs/ext2/xattr_user.c fs/ext2_ljj/xattr_user.c
--- fs/ext2/xattr_user.c	2024-11-01 08:56:07.000000000 +0800
+++ fs/ext2_ljj/xattr_user.c	2024-11-04 11:48:27.270696556 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * linux/fs/ext2/xattr_user.c
+ * linux/fs/ext2_ljj/xattr_user.c
  * Handler for extended user attributes.
  *
  * Copyright (C) 2001 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
@@ -8,28 +8,28 @@
 
 #include <linux/init.h>
 #include <linux/string.h>
-#include "ext2.h"
+#include "ext2_ljj.h"
 #include "xattr.h"
 
 static bool
-ext2_xattr_user_list(struct dentry *dentry)
+ext2_ljj_xattr_user_list(struct dentry *dentry)
 {
 	return test_opt(dentry->d_sb, XATTR_USER);
 }
 
 static int
-ext2_xattr_user_get(const struct xattr_handler *handler,
+ext2_ljj_xattr_user_get(const struct xattr_handler *handler,
 		    struct dentry *unused, struct inode *inode,
 		    const char *name, void *buffer, size_t size)
 {
 	if (!test_opt(inode->i_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext2_xattr_get(inode, EXT2_XATTR_INDEX_USER,
+	return ext2_ljj_xattr_get(inode, EXT2_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
 static int
-ext2_xattr_user_set(const struct xattr_handler *handler,
+ext2_ljj_xattr_user_set(const struct xattr_handler *handler,
 		    struct user_namespace *mnt_userns,
 		    struct dentry *unused, struct inode *inode,
 		    const char *name, const void *value,
@@ -38,13 +38,13 @@
 	if (!test_opt(inode->i_sb, XATTR_USER))
 		return -EOPNOTSUPP;
 
-	return ext2_xattr_set(inode, EXT2_XATTR_INDEX_USER,
+	return ext2_ljj_xattr_set(inode, EXT2_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
-const struct xattr_handler ext2_xattr_user_handler = {
+const struct xattr_handler ext2_ljj_xattr_user_handler = {
 	.prefix	= XATTR_USER_PREFIX,
-	.list	= ext2_xattr_user_list,
-	.get	= ext2_xattr_user_get,
-	.set	= ext2_xattr_user_set,
+	.list	= ext2_ljj_xattr_user_list,
+	.get	= ext2_ljj_xattr_user_get,
+	.set	= ext2_ljj_xattr_user_set,
 };
